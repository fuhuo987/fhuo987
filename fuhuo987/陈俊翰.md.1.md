[TOC]

# 前言
这里是陈俊翰学习前端知识的相关笔记
我尽量保持一天一更
因为之前有看过视频所以前面会比较快
写笔记就当复习一遍了
笔记纯手打，错字致歉
* **
* **
# HTML
* ## HTML是一种标记语言  

标签有两种形式，分别为单标签和双标签
双标签如
 ```c
 <div></div>
 <h1></h1>
```
单标签如
```c
<img>
```
* **
* ## 标题标签 

标题标签是双标签
由大到小从h1到h6
<h1>1</h1>
<h2>2</h2>
<h3>3</h3>
<h4>4</h4>
<h5>5</h5>
<h6>6</h6>

标题标签自带加粗
标签的合理运用可以提高SEO
* **
* ## 图片标签 

图片标签是一种单标签，用```<img>```表示，一般打出来长这样```<img src="" alt="" title="" width="" height="">```。其中```src```属性表示路径，需要在这里输入图片的地址，```alt```属性表示图片无法显示时显示的替代文本，```height```和```width```是图片的高和宽，不过一般只输入一个，不然会导致图片变形，title属性表示鼠标悬停在图片上时显示的文字提示。

这里附上我实际写下来的代码作为示例
```c
<img src="283pro.png" alt="" class="283pro" width="400px" style="float: right;" title="点击进入283PRO">
```
因为图片和html文件在一个文件夹里所以直接写了名字。

这里又可以引出图片路径的三种形式，分别是：**<u>绝对路径</u>,<u>相对路径</u>,<u>网络路径</u>**

绝对路径是电脑盘符存储和访问的具体地址，就类似于```D:\wenjian\1234.png```

相对路径是指两者相对关系，如果两者在同一路径下可以直接访问
**1. 子级关系：```/```**
**1. 父级关系：```../```**
**1. 同级关系：```./```（可以省略）**

网络路径就需要写出具体的网络地址
* **
* ## 超文本链接

超文本链接用```<a></a>```表示，他可以是一个字一个词也可以是一个图像，可以通过点击这些内容来跳转到新的文档或者当前文档的某个部分，需要在其```href=“”```中填入跳转网页的地址。

链接将以<font color=Blue><u>蓝色带有下划线</u></font>的字体显示，访问过的链接显示为<font color=Purple><u>紫色带有下划线</u></font>,样式后期可以通过css修改。

比如，我想实现通过点击图片进入游戏的效果，我就可以通过```<a><img></a>```来做到，就像这样：
```
<a href="https://shinycolors.enza.fun/" target="_blank">
<img src="283pro.png" alt="" class="283pro" width="400px" style="float: right;" title="点击进入283PRO">
</a>
```
这里的```target```属性表示新的链接怎么打开，方便控制链接的行为
```_blank``` 链接在新窗口打开
```_parent``` 链接在父窗口打开
```_self``` 默认值，链接在当前窗口打开
```_top``` 在顶层窗口打开
* **
* ## 列表标签

列表标签分为有序列表和无序列表
有序列表通过```<ol><li></li></ol>```来实现
```
<ol>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
</ol>
```
<ol>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
</ol>
列表可以嵌套，可以在一个列表里嵌套另一个列表

```
<ol>
<li>这是一个有序列表</li>
<li>abcd
    <ol>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
    </ol>
</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
</ol>
```
<ol>
<li>这是一个有序列表</li>
<li>abcd
    <ol>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
    </ol>
</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
</ol>

与有序列表相似，无序列表通过```<ul><li></li></ul>```进行表示

```
<ul>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
</ul>
```
<ul>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
</ul>

无序列表常用于做导航效果
* **
* ## 块元素和行内元素

HTML5中元素分类更加细致，但这里还是按照块元素和行内元素来进行学习
| 块级元素 | 内联元素 |
|-----------|------------|
| 块元素会在页面中占据一行（自上而下垂直排列） | 行内元素只会占据自身大小 |
| 块元素可以设置```width```,```height```属性 | 设置这两个属性无效 |
| 一般块元素可以包含其他块元素 | 一般行内元素包含行内元素不包含块级元素|

常见的块级元素有
```div、form、h1~h6、p、table、ul```等等等等

常见的行内元素有
```a、b、em、span、strong```等等等等

还有一些行内块级元素（不换行但是能够识别宽高）
```button、img、input```等等等等
  
  页面布局时需要考虑各个元素的特点
* **
* ## html文件的一般格式

现在才想起来这个还没说。。。
在Visual Studio Code里新建一个html文件，输入 **!+回车键**时就会自动打出基本框架，大概长这样
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

</body>
</html>
```
```body```部分是文档的主体，也是用户可以直接看到的内容，```head```里面描述了文档的各种信息，也可以在head里```link```css文件（外部样式）或者写```<style></style>```（内部样式），这些放到下面css的笔记中。
* **
* **
# CSS
* ## 简介

CSS(Cascading Style Sheets)层叠样式表，又叫级联样式表，简称样式表，CSS文件的后缀名为```.css```。

css的目的是让网页更加美观一致

CSS的规则由两个主要部分构成：**选择器，一条或多条声明**
如
```
div{
background-color: blue;
width: 200px;
}
```
每条声明由属性和值构成，属性和值通过冒号分开。
* **
* ## CSS的引入方式

CSS有三种引入方式，分别为：**内联样式、内部样式、外部样式**

**内联样式（行内样式）**
通过在元素后面加上```style```属性来引入css。
```
<img src="283.png" alt="" id="bz" style="user-select: none;">
```
这里就通过内联样式引入了css，将```user-select```属性的值改为了```none```，使图片不可被用户选中。

内联样式不利于维护，尽量少用

**内部样式**
当单个文档需要特殊的样式时就可以使用```<style></style>```标签在文档头部定义内部样式表

**外部样式**
当样式需要用到多个页面时，外部样式表就是一个好选择，可以在外部建立一个css文件，然后再文档头部通过```<link>```标签来进行引入
```
<link rel="stylesheet" href="./css/style.css">

<link rel="stylesheet" href="./css/color.css">
```
需要注意的是优先级的问题，这个放到后面的笔记中进行讨论。
* **
* ## 选择器

在这一部分中讨论css语法规则的一个主要部分：**选择器**

**全局选择器**
可以和任何元素匹配，优先级最低，一般做样式初始化
```
*{
    margin: 0;
}
```
<br>

**元素选择器**
选择文档中的元素，如``` p、div、img ```等等等等，可以描述这些元素的共性

```
table {
    margin-right: auto;
    margin-left: auto;
    border-collapse: collapse;
    table-layout:auto;
}
```
<br>

**类选择器**
相当灵活的选择器，首先先要通过```class```属性定义类，然后通过```.类名```来选择这一个类。注意类名不能以数字开头，同一个标签可以有多个类，通过空格隔开
```
.xz1{
    box-shadow:5px 8px 20px black ;
}
```
这个就是通过类选择器来给元素添加阴影的例子

**ID选择器**
与类选择器类似，需要先给元素定义一个```id```然后通过```#id名```进行选择，注意id尽量不要重复，同样也不能以数字开头

**合并选择器**
有些时候我们想同时选择多个元素，就可以用合并选择器的语法来减少重复代码，选择器之间用逗号隔开
```
table,th{
    border-collapse: collapse;
    border:2px solid black;
}
```
<br>

**选择器的优先级**
css中权重用数字衡量
元素选择器权重：1
类选择器权重：10
id选择器权重：100
内联样式：1000
如果是相同的样式，高权重的会覆盖低权重。

**关系选择器**
关系选择器分为**后代选择器、子代选择器、相邻兄弟选择器、通用兄弟选择器**

1. 后代选择器
选择所有被A包含的B元素用空格隔开
语法为```A B｛｝```
```
#background .jianjie {
    background: rgba(255, 255, 255, 0.5);
    width: 800px;
    margin-left: auto;
    margin-right: auto;
    margin-top: 50px;
}
```
2. 子代选择器
选择E元素的直接子元素F，对更深一层的元素不起作用，用>表示
语法为```E>F{}```

3. 相邻兄弟选择器
选择<u>**紧跟在E元素后**</u>的F元素，用+表示，语法为```E+F{}```

4. 通用兄弟选择器
选择**E元素之后的所有兄弟F元素**，用~表示，语法为```E~F{}```
* **
* ## 盒子模型

所有HTML元素都可以看作盒子，在css中“box model”这一术语是布局和设计时使用

css盒模型本质上是一个盒子，封装周围的HTML元素，它包括：
**外边距（margin）、边框（border）、内边距（padding）、实际内容（content）** 由外到内层层封装

1. margin外边距-清除边框外的区域，外边距是透明的
2. border边框-围绕在内边距和内容外的边框
3. padding内边距-清除内容周边区域，内边距是透明的
4. content实际内容-盒子内容，显示文字和图像

理解盒子模型可以帮助更好的布局网页
* **
* ## 一些常用属性

**字体属性** 
css字体属性定义字体、颜色、大小、加粗、文字样式
```                                                                                                                                                     
#background .box1 #biaoyucn {
    display: block;
    font-size: 50px;
    font-style: italic;
    font-family: "KaiTi";
    text-align: center;
    margin-top: 15px;
    margin-bottom: 0px;
}
```
<br>

**背景属性**
| 属性 | 描述 |
|-------|-------|
| ```background-color``` | 设置背景颜色|
|```background-image```|设置背景图片|
|```background-position```|设置背景图片显示位置|
|```background-repeat```|设置背景图片如何填充|
|```background-size```|设置背景图片大小|
<br>

**文本属性**
| 属性 | 描述 | 值|
|-------|-------|-----|
|```text-align``` | 指定元素文本的水平对齐方式|**left**:默认，文本居左排列；<br>**right**：文本排列到右边；<br>**center**：文本排列到中间|
|```text-decoration```|规定添加到文本的修饰|**underline**：下划线；<br>**overline**：上划线；<br>**line-through**：删除线|
|```text-transform```|控制文本大小写|**captialize**：每个字母开头大写；<br>**uppercase**：全部字母大写；<br>**lowercase**：全部字母小写|
|```text-indent```|规定文本块中首行字母的缩进|/|
<br>

**表格属性**
| 属性 | 描述 |
|-------|-------|
|``` border``` | 设置表格边框|
|```border-collapse```|设置表格边框是否被折叠成一个单一的边框或隔开|
|```width/height```|设置表格宽度/高度|
|```text-align```|设置表格中文本对齐属性|
|```color/background-color```|设置颜色/背景颜色|
<br>

* **
* ## 浮动

```float```属性定义元素在哪个方向浮动，任何元素都可以浮动

浮动只有左右浮动，没有上下浮动
浮动后的元素脱离了文档流，相当于ps里图层格外上加了一个图层，所以会出现折叠现象

当所有元素浮动的时候，会变成水平摆放，向左或向右，当容器不足时会在下一行摆放
* **
* ## 清除浮动
浮动的元素由于脱离了文档流，会导致其父元素高度塌陷，如果不想发生这种情况，就需要清除浮动带来的副作用

一般会用到四种方法

1. 父元素设置高度
给父元素设置```height```属性，将父元素撑开即可
2. 将受影响的元素增加```clear```属性
3. 如果父级塌陷，并且同级元素也受到了影响，可以在父级元素的样式里增加```overflow:hidden```，并在子级的样式里加```clear```属性
4. 通过伪元素的方法解决
在父标签添加伪类```after```，设置空的内容，并且使用```clear:both```注意父布局不设置高度
* **
* ## 定位

```position```属性指定了元素的定位类型
|值|描述|
|--|--|
|```relative```|相对定位|
|```absolute```|绝对定位|
|```fixed```|固定定位|
<br>

在设置定位之后可以使用```left、top、right、bottom```进行调整位置
**相对定位**
对象仍然处于常规的文档流中，但可以通过上面四个属性调整位置

**绝对定位**
对象脱离了文档流，此时偏移属性参照的是距离自身最近的定位祖先元素，如果没有定位的祖先元素，将追溯到```body```元素，每个绝对定位都像新开了一个图层，会出现覆盖情况，可以用```z-index```来调整

**固定定位**
与绝对定位相似，但偏移定位是以窗口为参考，用户滚动窗口时位置不变，具体应用就像广告栏和那种糊脸的广告

用好定位可以使界面更加美观，同时使模块发挥作用
* **
* ## 动画
动画可以使元素从一种样式逐渐变化为另一种样式

可以使用 **@keyframes** 来创建动画
```
@keyframes name{
    from|0%{
        css样式
    }
    percent{
        css样式
    }
    to|100%{
        css样式
    }
}
```
```name```：动画名称
```percent```：百分比值，可以添加多个

**animation执行动画**
```animation: name duration timing-function delay iteration-count direction;```
|值|描述|
|---|---|
|```name```|动画名称|
|```duration```|动画持续时间|
|```timing-function```|设置动画的速率|
|```delay```|设置动画的开始时间|
|```iteration-count```|动画循环次数，infinite为无限次循环|
|```direction```|播放方向|
|```animation-play-state```|控制动画的播放状态：running表示播放，paused表示暂停|
<br>

|timing-function的值|描述|
|----|----|
|```ease```|默认，逐渐变慢|
|```linear```|匀速|
|```ease-in```|加速|
|```ease-out```|减速|
|```ease-in-out```|先加速后减速|
<br>

|direction的值|描述|
|----|----|
|```normal```|默认，向前播放|
|```alternate```|偶数次向前播放，奇数次反向播放|
* **
* ## css嵌套

css嵌套使样式表更加容易阅读、模块化，同时也更容易维护，因为不需要重复选择器，文件同样可以被压缩

1.**子选择器**
可以使用css嵌套来创建一个父级的子选择器，这可以用来选择特定父元素的子元素，使用```&```来实现

有几个特定环境可以使得`` `&``` 嵌套选择器变得很必要或者有用：

-   在连接选择器时，如组合选择器或伪类
-   为了向后兼容。
-   作为一个辅助阅读的标志。当你看到 ```&``` 时，你就知道这里用到 CSS 嵌套了。
```
/* 不使用嵌套选择器 */
parent {
  /* 父样式 */
  child {
    /* 父级的子样式 */
  }
}

/* 使用嵌套选择器 */
parent {
  /* 父样式 */
  & child {
    /* 父级的子样式 */
  }
}

/* 浏览器均会把以上两个样式表解析为 */
parent {
  /* 父样式 */
}
parent child {
  /* 父级的子样式 */
}
```
2.**关系选择器**
css关系选择器也可在使用或不使用```&```嵌套选择器的情况下使用

```
h2 {
  color: tomato;
  + p {
    color: white;
    background-color: black;
  }
}
```
如果使用```&```嵌套选择器，只需在```+```前面加个```&```即可

3.**组合选择器**
与关系选择器不同，在使用组合选择器时，必须使用```&```嵌套选择器，这是因为浏览器会自动在不使用```&```嵌套选择器的选择器之间添加空格
```
.a {
  /* 带有 class="a" 元素的样式 */
  .b {
    /* 带有 class="b"，且为 class="a" 元素的子元素的样式 */
  }
  &.b {
    /* 带有 class="a b" 元素的样式 */
  }
}

/* 浏览器会将其分析为 */
.a {
  /* 带有 class="a" 元素的样式 */
}
.a .b {
  /* 带有 class="b"，且为 class="a" 元素的子元素的样式 */
}
.a.b {
  /* 带有 class="a b" 元素的样式 */
}
```

4.**后附嵌套选择器**
```&```嵌套选择器可以放到一个选择器的后方，这样可以反转上下文
```
.foo {
  /* .foo 的样式 */
  .bar & {
    /* .bar .foo 的样式 */
  }
}
```
<br>

如果一个嵌套 CSS 规则无效，那么所有其包含的样式都将被忽略。这不影响其父级及其后面的规则。

使用css嵌套可以将包含任何样式的at规则嵌入到另一个规则中。嵌套在at规则从距离它们最近的祖先规则中获得选择器定义

可以被嵌套的at规则有：

1. ```@media```
2. ```@support```
3. ```@layer```
4. ```@scope```
5. ```@container```

以```@media```为例，使用at规则嵌套的css为：
```
.foo {
  display: grid;
  @media (orientation: landscape) {
    grid-auto-flow: column;
  }
}
```
此时浏览器解析嵌套块是这样的：
```
.foo {
  display: grid;
  @media (orientation: landscape) {
    & {
      grid-auto-flow: column;
    }
  }
}
```
如果不使用at嵌套，那么它的等价表示是：
```
.foo {
  display: grid;
}

@media (orientation: landscape) {
  .foo {
    grid-auto-flow: column;
  }
}
```

at规则也可以嵌套其他at规则，如：
```
.foo {
  display: grid;
  @media (orientation: landscape) {
    grid-auto-flow: column;
    @media (min-width: 1024px) {
      max-inline-size: 1024px;
    }
  }
}
```
如果不使用嵌套的方法，它的等价表示是这样：
```
.foo {
  display: grid;
}
@media (orientation: landscape) {
  .foo {
    grid-auto-flow: column;
  }
}
@media (orientation: landscape) and (min-width: 1024px) {
  .foo {
    max-inline-size: 1024px;
  }
}
```
<br>

**嵌套的优先级**
```&```嵌套选择器的优先级由它所关联的选择器列表中优先级最高的选择器决定
```
<b class="foo">
  <c>蓝色文字</c>
</b>
```
```
#a, b {
  & c {
    color: blue;
  }
}

.foo c {
  color: red;
}
```
在这个示例中，ID 选择器（```#a```）的优先级是 ```1-0-0```，而类型选择器（```b```）的优先级是 ```0-0-1```。```&``` 嵌套选择器有 ```1-0-0``` 的优先级，尽管 ID 选择器 ```#a``` 从未使用。

类选择器 ```.foo``` 的优先级是 ```0-1-0```。经过计算得出，```& c``` 的总优先级是 ```1-0-1```，而 ```.foo c``` 的优先级是 ```0-1-1```，意味着 ```color: blue;``` 是最后赢家

在使用嵌套选择器的时候要注意优先级问题
*  **
* ## At规则
由于上文提到了at规则，于是在这里再做一下笔记

at规则是一个css语句，用来指示css如何运行，以```@```开头后跟一个标识符，并包括直到下一个分号的所有内容，或下一个 CSS 块，以先到者为准

下面是一些不同的at规则：
| 名称 |描述 |
|--|--|
|```@charset``` | 定义样式表使用的字符集|
| ```@import``` |告诉 CSS 引擎引入一个外部样式表 |
| ```@namespace``` | 告诉 CSS 引擎必须考虑 XML 命名空间 |
<br>

嵌套 at 规则，是嵌套语句的子集，不仅可以作为样式表里的一个语句，也可以用在条件规则组里：
| 名称 |描述  |
|--|--|
| ```@media``` |如果满足媒介查询的条件则条件规则组里的规则生效  |
|```@supports```  | 如果满足给定条件则条件规则组里的规则生效 |
|```@document```  |如果文档样式表满足给定条件则条件规则组里的规则生效  |
|``` @page``` | 描述打印文档时布局的变化 |
| ```@font-face``` | 描述将下载的外部的字体 |
| ```@keyframes``` | 描述 CSS 动画的中间步骤 |
| ```@layer```| 声明一个级联层，并在有多个级联层时定义优先顺序。|
<br>

**条件规则组**
每条at规则都有不同的语法，但一些at规则可以被归为一个特殊的分类：条件规则组。它们都使用相同的语法，它们都表达：它们所指的条件 (类型不同) 总等效于 **true** 或者 **false**，如果为 **true** 那么它们之中的语句生效。如```@media```、```@supports```、```@document```
* **
* ## 媒体查询

媒体查询可以使页面在不同终端下显示不同效果，会根据设备的大小自动识别加载不同的样式

**设置```meta```标签**
在```<head>```里加入这个```meta```标签能将使用设备的宽度作为初始宽度并禁止初始缩放
```
<meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1,user-scalable=no">
```
1. ```width=device-width```宽度等于当前设备的宽度
2. ```initial-scale=1.0```初始的缩放比例（默认1.0）
3. ```maximum-scale=1```允许用户缩放到的最大比例（默认1.0）
4. ```user-scalable=no```用户是否可以手动缩放 (默认是no）

```
@media screen and(max-width:768px)
/*设备小于768px加载样式 */
    body{}
}
@media screen and(max-width: 992px)and(min-width:768px){
/*设备大~~删除线文本~~于768px但小于992px加载样式 */
    body{}
}
@media screen and(min-width:992px){
/*设备大于992px加载样式*/
    body{}
}
```
* ## flex布局
Flexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。

之所以称flexbox是一种一维的布局，是因为它不像grid布局一样可以同时处理行和列，它一次只能处理一行或者一列上的元素布局。

flexbox有两根轴线：**主轴**和**交叉轴**，主轴由```flex-direction```定义，可以取以下四个值：

1. ```row```（默认）
2. ```row-reverse```
3. ```column```
4. ```column-reverse```

有```-reverse```的相比没有的起始线和终止线相反![输入图片说明](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox/basics5.svg)

选择```row```或```row-reverse```主轴按行的方向延伸，反之主轴将上下延伸

交叉轴垂直于主轴

flex容器有多种属性：
|属性  |值  |描述|
|--|--|----|
|```flex-direction```|**row（默认）<br> row-reverse column<br> column-reverse**  | 改变flex元素的排列方向    |
|```flex-wrap```| **wrap <br>nowrap（默认）** | 项目太大无法显示在一行中时换行显示    |
|```align-items```|**stretch**(默认，元素拉伸到最高元素的高度)<br> **flex-start**(顶部对齐) <br>**flex-end**(底部对齐) <br>**center**(居中对齐)|使元素在交叉轴方向对齐|
|```justify-content```|**flex-start**(默认，元素从起始线排列)<br> **flex-end**(从终止线开始排列) <br>**center**(在中间排列)<br> **space-around**(元素之间间隔相等)<br> **space-between**(元素的左右空间相等)|使元素在主轴方向上对齐|
|```align-content```|**flex-start**(与交叉轴的起点对齐)<br>**flex-end**(与交叉轴的终点对齐) **center**(与交叉轴的中点对齐) <br> **space-between**(与交叉轴两端对齐，轴线之间的间隔平均分布) <br>**space-around**(每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍) <br>**stretch**(默认值，轴线占满整个交叉轴)|定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用|
<br>

```flex-direction```和```flex-wrap```这两种属性可以合并写为```flex-flow: 值1 值2```,第一个指定的值为 ```flex-direction``` ，第二个指定的值为 ```flex-wrap```

flex元素也有多种属性：

|属性|描述  |
|--|--|
|```flex-grow```  | 定义了在有可用空间时的放大比例 |
| ```flex-shrink``` | 定义了在空间不足时的缩小比例 |
|```lex-basis```  | 指定了项目在分配空间前的初始大小 |
<br>

这几个flex属性的作用其实就是改变了flex容器的可用空间的行为（在把flex项目用到多行的时候，应该把每一行都看作一个新的flex容器），这三个属性可以合并成```flex: 值1 值2 值3```，三个值分别对应```flex-grow```，```flex-shrink```，```flex-basis```

大多数情况下用预定义的简写形式
| 简写 | 相当于 |
|--|--|
|```flex: auto```  | ```flex: 1 1 auto ```|
|```flex: initial```  | ```flex: 0 1 auto ```|
|```flex: none```  | ```flex: 0 0 auto``` |
| ```flex: 1``` | ```flex: 1 1 0``` |
| ```flex: 2``` | ```flex: 2 1 0``` |
|```flex: num```|```flex: num 1 0```


* **
* ## grid布局

grid布局即网格布局，引入了二维网格布局系统

网格是一组相交的水平线和垂直线，它定义了网格的行和列，可以把网格元素放在这些行列相关的位置上

网格布局的特点有：

1. **固定的位置和弹性的轨道大小**：既可以使用固定的轨道尺寸创建网格，也可以使用百分比或者```fr```来创建有弹性尺寸的网格
2. **网格项摆放**：可以使用行号、行名或者标定一个网格区域来精确定位元素，同时还使用一种算法来控制未给出明确网格位置的元素
3. **创建额外的轨道来包含内容**：可以通过网格布局定义显式网格。网格布局规范非常灵活，可以在需要时添加额外的行和列。包括添加“一个容器能容纳的尽可能多的列”等特性
4. **对齐控制**：网格包含对齐特性，因此我们可以控制项目放入网格区域后的对齐方式，以及整个网格的对齐方式
5. **控制重叠内容**：多个项目可以放置在网格单元格中，或者区域可以部分地彼此重叠。然后可以使用 ```z-index``` 属性来控制重叠区域显示的优先级

通过在元素上声明```display: 	grid```来创建一个网格容器，里面的所有直系子元素都将成为网格项目

使用 ```grid-template-rows```和 ```grid-template-columns```属性定义网格上的行和列。这些属性定义了网格轨道。_网格轨道_（grid track）是网格上任意两条相邻线之间的空间。

轨道可以使用任何长度单位进行定义，也可以使用一个新单位```fr```来定义轨道大小，也可以混合使用单位如```grid-template-columns: 500px 1fr 2fr;```就是在可用空间扣除了500px宽度后再一分为三按比例分配

包含多个轨道的大型网格可使用 ```repeat()``` 标记来重复部分或整个轨道列表，如```grid-template-columns: 1fr 1fr 1fr;```就可以写成```grid-template-columns: repeat(3,1fr);```。同时```repeat()```也可以重复轨道列表中的一部分。如果是```repeat(5,1fr,2fr)```就意味着网格有十个轨道，为1个```1fr```后面跟着一个```5fr```，这样重复五次

如果希望行或列的大小永远不会小于一个值时，可以使用```minmax()```函数，如 ``` grid-auto-rows: minmax(100px, auto);```就意味着行高度最小为100px，最大为auto，使用 auto 表示大小将取决于内容的大小，并将拉伸以在该行中为单元格中最高的项目留出空间。

在定义网格时，定义的是网格轨道而非网格线，一个三行两列的网格中有四条纵向的网格线，网格线的编号顺序取决于文章的书写格式，网格线也可以被命名

使用 ```grid-column-start```、```grid-column-end```、```grid-row-start``` 和 ```grid-row-end``` 属性可以将项目放到自己想要的位置，也可以跨轨道放置，注意目标是网格线而不是网格轨道。这个有简写，如：```grid-column```和```grid-row```，值为 ```值1/值2```，值1为起始网格线，值2为终止网格线，也可以更进一步，合并为```grid-area```属性，同样用```/```分开，值的顺序为```grid-row-start```/```grid-column-start```/```grid-row-end```/```grid-column-end```

项目可以按行或者列跨越一个或多个单元格，形成了一个*网格区域*，网格区域必须是矩形的

网格单元格之间的横向间距或纵向间距可以使用```column-gap```和```row-gap```属性（简写为```gap```）

网格间距使用的任何空间都会在分配给灵活长度的 ```fr``` 轨道之前计算在内，而且网格间距的大小与常规网格轨道相同，但不能在间距中放置任何东西。就基于行的定位而言，网格间距就像一条粗线。

网格也可以嵌套，将一个网格项作为一个网格容器，如果不使用子网格的嵌套，那么嵌套网格和父网格没有任何关系，不会继承父网格的属性

*子网格*(subgrid)能让在创建嵌套网格的同时使用父网格的轨道定义，如将 ```grid-template-columns: repeat(3,1fr)```的轨道定义更改为 ```grid-template-columns: subgrid```。嵌套网格就会沿用父网格轨道来布局项目。

网格项可以占据同一单元格，可以使用```z-index```属性改变堆叠顺序（这里好像和绝对定位挺像的），就是当一个单元格被两个网格区域覆盖时就可以改变```z-index```的值决定谁在上面

在抉择布局方式时，应该思考是**只需要按行或者列布局**还是要**同时按行和列布局**，以此决定使用弹性盒子布局还是网格布局

css的网格布局是一种很好用的工具，应该大胆尝试与其他布局方法混用，获得想要的页面效果
* **
 * # JavaScript
 *  ## 简介
 
JavaScript是一种轻量级的脚本语言，所谓脚本语言，就是指它不具备开发操作系统的能力，只用来编写其他大型应用程序的脚本

JavaScript是一种嵌入式语言，它本身提供的核心语法不算很多

*  **
* ## JavaScript的语句和标识符
JavaScript程序单位是行，一般情况下一行就是一个语句，语句以分号结尾，一个分号表示一个语句结束

标识符指的是用来识别各种值的合法名称，最常见的就是各种变量名称，注意不能以数字开头
* **
* ## JavaScript引入方式
和css类似，JavaScript也有三种常用引入方式：

1. 嵌入到html文件中
用```<script></script>```标签包含js代码
2. 引入本地js文件
语法如```<script src="./js/1.js"></script>```在```src```里写入js文件的地址即可
3. 引入网络来源文件
即在```<script src=""></script>```的```src```里填入网络来源的js文件地址


* **
* ## 常用运算符
**typeof运算符**
JavaScript有三种方法可以确定一个值是什么类型，最先接触到的是```typeof```

1. 数值返回number
2. 字符串返回string
3. 布尔值返回boolean
4. 对象返回object
5. 没有数值返回undefined
<br>

**算数运算符**
| 运算符 | 描述 |
|--|--|
| ```+``` | 加 |
|``` -``` | 减 |
|``` * ```| 乘 |
| ```/``` | 除 |
|``` % ```| 取余 |
| ```p++``` | 先运算再自增 |
|``` ++p ```| 先自增再运算 |
<br>

**赋值运算符**
| 运算符 | 描述 |
|--|--|
|``` = ```| 赋值运算符 |
|``` +=``` | x+=y等同于x=x+y |
| ```-= ```| x-=y等同于x=x-y |
| ```/= ```| x/=y等同于x=x/y|
|``` *=``` | x*=y等同于x=x*y |
| ```%=``` | x%=y等同于x=x%y |
<br>

**比较运算符**
| 运算符 | 描述 |
|--|--|
|```<``` | 小于 |
| ```>``` | 大于 |
|``` <=``` | 小于等于 |
| ```>=``` | 大于等于 |
|``` ==``` | 相等 |
| ```===``` | 严格相等 |
| ```!= ```| 不等于 |
| ```!==``` | 严格不等于 |
<br>

**布尔运算符**
| 运算符 | 描述 |
|--|--|
|``` ! ```| 取反 |
| ```&&``` | 且 |
| ```||``` | 或 |
 * **
 *  ##条件语句
 
 **if语句**
 if语句先判断一个表达式的布尔值，然后根据布尔值的真伪执行不同的语句，语法如下：
 ```if(flag){要执行的语句}```
 
 **if...else语句**
 if代码块后面可以跟一个else代码块，表示不满足条件时要执行的代码，语法如下：
  ```
  if(flag){
        要执行的语句
    }else{
        要执行的语句
    } 
```
如果在不同条件下要执行不同的代码，可以使用if...else if...else语句，else if可以任意多，语法如下：
```
  if(flag){
        要执行的语句
    }else if(flag2){
        要执行的语句
    }else{
        要执行的语句
    } 
```
<br>

**switch语句**
在有多种选择的情况下也可以考虑使用switch语句，注意的是每一个```case```最后都要有一个```break```，否则会继续执行下一个case代码块，语法如下：
```
   switch(变量){
       case 值1:
           代码块
           break;
       case 值2:
           代码块
           break;
       case 值3:
           代码块
           break;
       default:
           代码块
   }
```
* **
* ## 循环语句
循环语句就是重复执行某个操作

**for语句**
for语句就是循环命令，可以指定循环的起点、终点和终止条件，语法如下：
```
for(初始化表达式;条件;循环因子){
    要循环的语句
    }
```
其中初始化表达式只在循环开始时执行一次，条件每轮循环开始时都要执行一遍，只有布尔值为真时才执行此次循环，循环因子是每轮循环的最后一次操作，通常用来递增循环变量

** while语句**
while语句包含一个循环条件和代码块，只要条件为真就执行代码块，直到条件为假时或遇到```break```跳出循环，语法如下：
```
while(条件){要循环的语句}
```
需要注意的是在语句内应该有改变与条件有关变量的语句或```break```语句，防止出现死循环

所有for循环都可以写成while循环，反之亦然

循环语句可以嵌套，通过循环语句嵌套可以实现想要实现的效果

**break语句和continue语句**
```break```和```continue```都可以让代码不按原有的顺序进行

```break```语句用于跳出代码块或者循环，遇到```break```意味着循环的结束

```continue```语句意味着立刻终止本轮循环，返回循环体的头部，开始下一轮循环
 *   **
 *  ## 字符串

字符串就是零个或多个排在一起的字符放在单引号和双引号之中

单引号可以嵌套双引号，双引号可以嵌套单引号，但不能相同引号嵌套。如果要使用相同引号嵌套，就得在引号前添加```\```用来转义

字符串默认只能一行显示，如果要换行需要转义

**charAt**通过输入的下标数字传递相应的字符，如果参数为负数或大于等于字符串的时候，它返回空字符

**concat**用来合并两个字符串，返回一个新字符串，不改变原字符串，语法为```str1.concat(str2)```，将str2合并到str1后面。参数可以有多个（用逗号隔开），如果参数不是字符串，会将参数先转化为字符串再拼接

连接字符串可以不用```concat```，用```+```连接效果一样还简单。但是```concat```完全不会做运算，如果是```+```的话，两个数字会做加法运算而不是转化为字符串连接，只有遇到字符串才会转化为字符串

**substring**是用来截取字符串的方法，从原字符串取出子字符串并返回，不改变原字符串。两个参数分别是首位置下标和末位置下标，但是不包含末位置。（就是字符串切片的方法）

第二个参数不写默认到原字符串结尾，如果第一个参数大于第二个参数它会自动更改两个参数位置。如果参数是负数，它会自动把参数转化为0

**substr**和```substring```作用差不多，都是从原字符串取出子字符串并返回，不改变原字符串。第一个参数是首位置下标，第二个参数是子字符串的长度

如果省略第二个参数就会一直到原字符串的结束。第一个参数如果是负数，表示倒数计算的字符位置；第二个参数如果是负数就会被自动转化成0，最后返回空字符串

**indexOf**方法用来确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始时的位置，如果不匹配就返回```-1```

该方法还能接受第二个参数，表示从该参数位置后进行查找

**trim**用来去掉字符串两端的空格，返回一个新字符串，不改变原字符串

它不仅能去除空格，还能取出制表符（```\t```、```\v```）、换行符（```\n```）回车符（```\r```）

ES6还新增了```trimEnd```和```trimStart```方法，一个去尾部一个去头部

**split**方法用来按给定规则分割字符串，返回一个由分割字符串组成的数组

如果分割规则是空字符，那么数组的成员就是每一个字符
如果省略参数，那么数组的唯一成员就是原字符串

该方法还能接收第二个参数，限定返回数组的最大成员数
 * **
 * ## 数组

**数组**是按次序排列的一组值，每个值都有编号，整个数组用方括号表示。两端的方括号是数组的标志，任何类型的数据都能被放入数组。可以用```length```属性返回数组的成员数量

数组的遍历可以用for循环或者while循环

还有```for...in```遍历数组，格式如下
```
for(var i in a){
    console.log(a[i]);
}
```
<br>

**Array.isArray** 可以判断对象是不是数组，它可以弥补```typeof```的不足

**push**用来在数组的**末端**添加一个或多个元素，并返回添加后新数组的长度，该方法会改变数组

**pop**方法用来删除数组的**最后一个元素**并返回该元素，该方法同样会改变数组

**shift**方法用来删除数组的**第一个元素**并返回该元素，该方法会改变数组

**unshift**方法用来在数组的**首端**添加一个或多个元素，并返回添加后新数组的长度，该方法会改变数组

**join**方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回，没有指定参数默认以逗号分隔

如果数组成员是```undefined```或者```null```，会被转为空字符串

```join```和```split```可以实现数组和字符串的互换

**concat**不止用来合并字符串，也可以将一个数组的成员添加到原数组的后面，返回一个新数组，原数组不变。除了将数组作为参数，也可以将其他类型的值作为参数添加到目标数组后面

**reverse**方法用来颠倒数组元素并返回改变后的数组，会改变原数组

**indexOf**方法也可以对数组使用，效果一样，但是查找的是给定元素在数组里第一次出现的位置

* **
* ## 函数

函数由```function```命令来进行声明，function命令声明的代码区块就是一个函数，```function```后面跟着函数名，函数名后面是括号，里面包含着传入函数的参数，函数体在后面的大括号里面

函数可以先调用再创建，因为函数会自动提升到代码头部

函数用```return```将值返回给外界
 * **
 * ## 对象
对象是JS的核心概念，也是重要的数据类型，它是一组键值对的集合，是一种无序的复合数据集合，形如：
```
var user={
    name:'fuhuo',
    num: 1234
};
```
对象的每一个键名又称为**属性**，它的键值可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为**方法**，它可以像函数一样被调用

如果属性的值还是对象，就形成了链式引用

对象的读取方式是通过```对象名.属性```来进行调用
 * **
 * ## Math对象
Math是JS的原生对象，提供各种数学功能
|对象名|功能  |
|--|--|
| ```Math.abs()``` | 返回参数的绝对值 |
| ```Math.max()/Math.min()``` | 返回参数之中的最大值/最小值 |
| ```Math.floor()/Math.ceil``` | 返回小于/大于参数的最大整数 |
| ```Math.random()``` | 返回0~1之间的一个伪随机数，可能为0但一定小于1 |

* **
* ## Date对象

```Date.now()```返回当前时间距离时间零点（1970年1月1日 00：00：00UTC）的毫秒数

Date对象提供了一系列get方法，用来获取实例对象某个方面的值
|方法|描述  |
|--|--|
| ```getTime()``` | 返回实例距离1970年1月1日 00：00：00的毫秒数 |
| ```getDate()``` | 返回实例对象对应每个月的几号 |
| ```getDay()``` | 返回星期几，星期日为0，星期一为1 |
| ```getYear()``` | 返回距离1900的年数 |
| ```getFullYear()``` | 返回四位的年份 |
| ```getMonth()``` | 返回月份（0是1月） |
| ```getHours()``` | 返回小时（0~23） |
| ```getMilliceconds``` | 返回毫秒（0~999） |
| ```getMinutes``` | 返回分钟（0~59） |
| ```getSeconds``` | 返回秒（0~59） |

 * **
 * ## DOM
DOM是JS操作网页的接口，全称为“文档对象模型”（Documm Object Model），它的作用是将网页转为一个JS对象，从而可以用脚本进行各种操作

浏览器会根据DOM模型将结构化文档HTML解析成一系列节点，再由这些节点组成一个树状结构（DOM Tree），所有的节点和最终的树状结构都有规范的对外接口

DOM只是一个接口规范，可以用各种语言实现，但DOM操作是JS的常见任务，离开了DOM，JS就无法操作控制网页，JS也是最常用于DOM操作的语言

DOM的最小组成单位叫做**节点**，文档的树形结构就是由不同的节点组成，每个节点都是文档树的一片叶子

节点有七种类型：

|节点| 描述 |
|--|--|
|**Document** | 整个文档树的顶层节点 |
|**DocumentType** | doctype标签 |
|**Element** | 网页的各种HTML标签 |
|**Attribute** | 网页元素的属性（如class=“abcd”） |
|**Text** | 标签之间或标签包含的文本 |
|**Comment** | 注释 |
|**DocumentFragment** | 文档的片段 |

**节点树：** 一个文档的所有节点按照所在的层级可以抽象成一种树状结构，这就是DOM树，它有一个顶层节点，下一层都是顶层节点的子节点，子节点也有自己的子节点，形成一个金字塔型结构，倒过来就像一棵树

除了根节点，其他节点有三种层级关系：

1. **父节点关系：** 直接的上级节点
2. **子节点关系：** 直接的下级节点
3. **同级节点关系：** 拥有同一个父节点的节点

<br>

**Node.nodeType属性**不同节点的nodeType属性值和对应的常量如下：

| 节点 | 属性值 | 对应的常量 |
|--|--|--|
|**文档节点**  | 9 | Node。DOCUMENT_NODE |
|**元素节点**  | 1 | Node.ELEMENT_NODE |
|**属性节点**  | 2 | Node.ATTRIBUTE_NODE |
|**文本节点**  | 3 | Node.TEXT_NODE |
|**文档片段节点**  | 11 | Node.DOCUMENT_FRAGMENT_NODE |
* **
* ## document方法
document方法可以获取元素
|方法| 描述 |
|--|--|
| ```document.getElementsByTagName()``` | 搜索HTML标签名，返回符合条件的元素，返回值是一个类似数组对象（HTMLCollection）。如果没有任何匹配的元素，返回一个空集，如果传入```*```就返回文档中所有HTML元素 |
|```document.getElementsByClassName()```|搜索所有class名字符合指定条件的元素，返回值是一个类似数组的对象（HTMLCollection）|
|```document.getElementsByName()```|搜索所有name名字符合指定条件的元素，返回值是一个类似数组的对象（HTMLCollection）|
|```document.getElementById()```|搜索所有ID名字符合指定条件的元素|
|```document.querySelector()```|该方法接受一个CSS选择器作为参数，如果有多个节点满足条件，返回第一个匹配的节点|
|```document.querySelectorAll()```|和```document.querySelector()```用法类似，区别是返回一个```NodeList```对象，包含所有匹配给定选择器的节点|
<br>
document方法也可以创建元素

|方法| 描述 |
|--|--|
| ```document.createElement()``` | 用来生成元素节点并返回该节点 |
| ```document.createTextNode()``` | 生成文本节点（Text实例）并返回该节点，它的参数是该文本节点的内容 |
| ```document.createAttribute()``` | 生成一个新的属性节点（Attr实例）并返回 ，通过```value()```来进行赋值。通过```setAttributeNode()```方法将属性放入标签中|
<br>

```appendChild()```方法可以将内容或子元素放到容器中
* **
* ## Element对象
Element对象对应网页的HTML元素，每一个HTML元素在DOM树上都会转化成一个Element节点对象

|属性|描述 |
|--|--|
| ```Element.id``` | 返回指定元素的```id```属性，可读写 |
| ```Element.className``` | 读取当前元素的class属性，它的值是一个字符串，每一个```class```之间通过空格分隔，也可以修改 |
| ```Element.classList``` | 有下列方法：<br>```add()```:增加一个class<br>```remove()```:移除一个class<br>```contains()```:检查当前元素是否包含某个class<br>```toggle()```将某个class移入或移出当前元素 |
| ```Element.innerHTML``` | 返回一个字符串，等同于该元素包含的所有HTML代码，该属性可以读写，能改写所有元素节点的内容，包括```<HTML>```和```<body>```元素 |
| ```Element.innerText``` | 与```Element.innerHTML```类似，不同的是它无法识别元素，会直接渲染成字符串 |

Element还能获取元素在页面中的位置
|属性| 描述 |
|--|--|
| ```clientHeight``` |获取元素高度包括```padding```部分但是不包括```border```和```margin```  |
| ```clientWidth``` | 获取元素宽度包括```padding```部分但是不包括```border```和```margin``` |
| ```scrollHeight``` | 元素总高度，包包括```padding```部分但是不包括```border```和```margin```包括溢出的不可见内容 |
| ```scrollWidth``` |元素总宽度，包包括```padding```部分但是不包括```border```和```margin```包括溢出的不可见内容  |
| ```scrollLeft``` | 元素的水平滚动条向右滚动的像素数量 |
| ```scrollTop``` | 元素的水平滚动条向下滚动的像素数量 |
| ```offsetHeight``` | 元素的CSS垂直高度（单位是像素），包括元素本身高度、```padding```和```border``` |
| ```offsetWidth``` | 元素的CSS水平宽度（单位是像素），包括元素本身高度、```padding```和```border``` |
| ```offsetLift``` | 到定位父级左边界的间距 |
| ```offsetTop``` | 到定位父级上边界的间距   |

* **
* ## 通过JS来操作CSS
操作CSS样式最简单的方法就是通过网页元素节点的```setAttribute```方法直接操作网页元素的```style```属性
```box.setAttribute("style",style属性)```
虽然简单但是不常用

第二种方法是通过元素节点的```style```属性来进行操作
```
var a=document.querySelector('div').style;
a.backgroundColor='red';
```
 <br>
 第三种方法是通过```cssText```属性进行操作
 ```
 var a=document.querySelector('div').style;
 a.cssText='background-color:red;';
 ```

不过我自己用的还有先在css里创建一个类选择器，然后通过增加类名来使元素节点具有那个类选择器里的属性
* **
* ## 事件处理程序
事件处理程序分为**HTML事件处理、DOM0级事件处理、DOM2级事件处理**

**HTML事件处理：**
```
<button onClick="shijian()">按钮</button>

<script>
function shijian(){
   要发生的事件代码
}
</script>
```
它的缺点就是HTML和JS没有分开

**DOM0级事件处理：**
```
<button id="btn">按钮</button>

<script>
var btn=document.getElementById("btn");
btn.onclick=function(){
   要发生的事件代码
}
</script>
```
这里HTML和JS分离，但无法同时添加多个事件，如果有多个事件会覆盖前面的事件

**DOM2级事件处理：**
```
<button id="btn">按钮</button>

<script>
var btn=document.getElementById("btn");
btn.addEventListener("click",function(){
要发生的事件代码
})
</script>
```
这里添加了事件监听器。使用```addEventListener```，它必须接受两个必须参数和一个可选参数。第一个参数是要监听的事件类型；第二个参数是当事件发生时要执行的函数；可选的第三个参数是一个布尔值

|常用的可以监听的事件| 描述 |
|--|--|
|**mousedown**  | 按下鼠标左键或者右键触发 |
|**mouseup**  | 松开鼠标左键或右键触发 |
|**mouseenter**  | 鼠标指针进入该元素的边界时触发，进入子节点不会触发 |
|**mouseleave**  | 鼠标指针离开该元素时触发，离开父节点不会触发 |
|**mouseover**  | 鼠标指针进入一个节点时触发，进入子节点会再一次触发该事件 |
|**mouseout**  | 鼠标指针离开一个节点时触发，离开父节点也会触发这个事件 |
|**click**  | 鼠标指针点击元素松开鼠标左键时触发 |
|**dbclick**  | 鼠标指针双击时触发 |
|**wheel**  | 鼠标滚轮转动时触发 |
|**keydown**  | 键盘的键按下时触发 |
|**keyup**  | 键盘的键松开时触发 |
|**submit**  | 当点击表单种的提交按钮时触发 |
|**reset**  | 当点击表单的重置按钮时触发 |
|**select**  | 检测用户在文本输入框中选择文本内容的操作 |

* **
* ## Event事件对象
事件发生后会产生一个事件对象，作为参数传给监听函数

Event事件对象可以分为**属性**和**方法**两部分去看

Event对象属性：**Event.Target**、**Event.Type**

**Event.Target**返回事件当前所在的节点
**Event.Type**返回的字符串表明当前事件类型

Event对象方法：**Event.preventDefault()**、**Event.stopPropagation()**

**Event.preventDefault**方法取消浏览器对当前事件的默认行为，比如点击链接浏览器会默认跳转到另一个页面，使用该方法后就不会跳转了
**Event.stopPropagation**方法阻止事件在DOM继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前事件上其他事件监听函数（子元素和父元素嵌套的时候阻止事件冒泡）

**事件代理：** 由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方法就叫做事件代理

* **
* ## 定时器
JS提供定时执行代码的功能，叫做定时器（timer），主要由```setTimeout()```和```setlnterval```两个函数来完成

```setTimeout```函数用来指定某个函数或者某段代码，在多少毫秒之后执行，它返回一个整数表示定时器的编号，以后可以用来取消这个定时器

它接受两个参数，第一个参数是将要推迟执行的函数名或一段代码，第二个参数是推迟执行的毫秒数
```var tm=setTimeout(func|code,delay);```
如果回调函数是对象的方法，那么```setTimeout```使方法内部的this关键字指向全局环境而不是定义时所在的那个对象

可以通过```clearTimeout(定时器名字)```来取消定时器

```setlnterval```和```setTimeout```用法完全一致，去别仅仅在于它指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行
* **
* ## 防抖与节流
防抖和节流应该是性能优化的知识，但是遇到的频率很高，处理不当会导致浏览器卡死
```
function showTop(){
    var scrollTop=document.documentElement.scrollTop;
    console.log('滚动条位置：'+scrollTop);
} 
window.onscroll=showTop
```
上面这段代码在执行的时候会发现一个问题，就是默认的执行频率太高了，实际上并不需要如此高频率的反馈，因为浏览器的性能是有限的

一种思路是在第一次触发事件时不立刻执行函数，而是给出一个期限值，如果在期限值内没有再次触发事件那么就执行函数，反之重新进行计时

防抖就是对于短时间内连续出发时间，让其在某个时间期限内事件处理函数只执行一次

节流就是每间隔一定时间触发一次事件处理函数
* **
* ## 命令行工具
常用的命令行工具有两种：**CMD**和**PowerShall**

CMD命令行：

1. 打开命令行窗口 
 ```win```+```r```快速打开命令行窗口
 2. 选择盘符：盘符名加冒号，大小写无所谓
 3. 查看盘符及目录文件下的文件和文件夹:```dir```
 4. 清空命令行信息```cls```
 5. 进入文件夹或目录```cd 文件夹名称```
 6. 返回上一级目录```cd ../```
 7. 快速补全目录或文件夹名称```tab```
 8. 创建文件夹```mkdir 文件夹名称```
 9. 查看历史输入过的命令：上下按键
<br>

PowerShall命令行：

1. 打开方式
在开始位置搜索```PowerShall```打开或者在对应目录```shift```+右键打开
2. 其他和上面一样
* **
* ## ECMAScript简介
ECMAScript和JS的关系是：前者是后者的规格，后者是前者的一种实现

ECMAScript（ES6）是JS语言的标准，它是为了使JS可以用来编写复杂的大型应用程序，成为企业级开发语言
* **
* ## var和let还有const
ES6新增了```let```命令用来声明变量，用法类似与```var``` ，但所声明的变量只在let命令所在的代码块（被大括号```{}```包括的部分）内有效

而```var```关键字的作用域是函数级的

下面以一段循环代码为例
```
var a=[]
for(var i=0;i<10;i++){
a[i]=function(){console.log(i);}
};
a[5]()
```
理论上说，我们想要它打印的是5，但是由于是用了```var```关键字，实际上打印出来的是10。这时候只要把```for```语句里的```var i=0```改成```let i=0```即可达到我们想要的效果

```var```关键字存在变量提升，可以先使用再声明，但```let```必须要先声明再使用，同时```let```也不允许重复声明 

```const```声明一个只读的常量，一旦声明，常量的值就不能被改变。同时这也意味着一旦声明```const```就必须立刻进行赋值，不能留到之后进行改变。它和```let```相同，只在声明所在的块级作用域内有效，它所声明的常量也不能提升和重复声明
* **
* ## 对象解构赋值
如果有这么一个变量
```
var user={
name='fuhuo',
psw='1234'
}
```
正常的读取是```user.name```或者```user.psw```，如果采用解构赋值```const{name,psw}=user;```就可以直接使用```name```和```psw```了

对象的属性没有次序，变量必须与属性同名才能取到值。
* **
* ## 字符串扩展
ES6加强了对Unicode的支持，允许采用```\uxxxx```形式表示一个字符，其中```xxxx```表示字符的Unicode码点

```for...of```遍历可以遍历字符串的每一个字符

**模板字符串**是增强版的字符串，用反引号(`)表示，可以当作普通字符串使用，也可以定义多行字符串，或者在字符串中嵌入变量，比如说要动态创建一个a标签
```
var wz1="<a herf='"+URL+"'>"+text+"</a>"
var wz2=`<a herf="${URL}">${text}</a>`
```
上面两种方法实现效果是一样的

传统上JS只有```indexOf()```方法可以确定一个字符串是否包含在另一个字符串中，但ES6又提供了三种方法：```includes()```、```startsWith()```和```endsWith```

```includes()```：返回布尔值，表示是否找到了参数字符串
```startsWith()```：返回布尔值，表示参数字符串是否在原字符串的头部
```endsWith()```：返回布尔值，表示参数字符串是否在原字符串的尾部

三个方法都支持第二个参数，表示开始搜索的位置

```repeat()```方法返回一个新字符串，表示将原字符串重复n次

ES2017引入了字符串补全长度的功能，如果某个字符串不够指定长度，会在头部或尾部补全```padStart()```用来头部补全，```padEnd()```用来尾部补全。它们接受两个参数，分别是补全后的长度和用来补全的字符串

ES2019新增了```trimStart()```和```trimEnd()```两种方法，这在前面字符串已经有过笔记

```at()```方法接受一个整数作为参数，返回参数指定位置的字符，支持负索引
* **
* ## 数组扩展
扩展运算符是三个点（```...```），将一个数组转为用逗号分隔的参数序列

```console.log(...[1,2,3,4]);```输出的就是```1 2 3 4```

因为扩展运算符可以展开数组，所以就不再需要```apply```方法将数组转为函数的参数了。```Math.max.apply(null,[1,2,3,4]);```等同于```Math.max(...[1,2,3,4]);```

扩展运算符提供了合并数组的新方法，之前合并数组用的是```arr1.concat(arr2)```，现在只需要```[...arr1,...arr2]```即可合并成一个新数组

```Array.from()```方法用于将类数组转为真正的数组

常见的类数组有：**arguments、元素集合、类似数组的对象**。类数组可以使用数组的读取方式和length属性，但是不能使用数组方法

**arguments**是指函数当中的可选参数
**元素集合**就比如```querySelectorAll()```方法获取的nodeList集合
**类似数组的对象**就像
```var user={
"0":"1234",
"1":1234,
"2":"567",
length:3,
}
```
这种看起来像数组但是不是数组的对象
<br>

```Array.of()```方法用来将不是数组的一组值变为数组，注意要和```Array()```方法区分，后者的参数表面开辟数组空间的个数
* **
* 对象的扩展
ES允许在大括号里面直接写入变量和参数作为对象的属性和方法，这样的书写方式更加简洁

正常是这么写的：
```
var name='fuhuo'
var user={
name:name,
age:20
}
```
通过属性简介表示法，当属性名和属性值是一样的变量名称就可以省略，上面的```name:name,```就可以写为```name,```

除了属性简写，方法也可以简写，还是上面的一段函数，我想加入一个方法，正常是这样的：
```
var name='fuhuo'
var user={
name:name,
age:20,
fangfa:function(){一串代码}
}
```
但是简写后就可以省略掉```:function```，只用写```fangfa(){一串代码}```即可

ES6允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号里面
```
var user={
username:'fuhuo',
num:123
}
```
修改后为：
```
var n="username"
var user={
[n]:'fuhuo',
num:123
}
```
<br>

ES2018将扩展运算符引入了对象
```
var a={z:1,x:2};
var b={...z,c:3};
```
* **
* ## 函数扩展
ES6允许使用箭头```=>```来定义函数
```
var 函数名=(参数)=>返回值
```
如果只有一个参数可以不用写括号，多个或没有参数都需要写括号

如果箭头函数的代码块多于一条语句，就要使用大括号把它们括起来，并使用```return```语句返回。由于大括号被解释为代码块，如果箭头函数直接返回一个对象需要使用括号括起来，如：```var hs=(x,y)=>({x:10,y:20});```

箭头函数的一个作用是简化回调函数（匿名函数）
```
var arr=[1,2,3,4];
arr.map(item=>{console.log(item);
})
```

对于普通函数来说，内部的```this```指向的是函数运行时所在的对象，但是这一点对箭头函数不成立，它没有自己的```this```对象，它内部的```this```就是定义时上层作用域的```this```
* **
* ## Set数据结构
ES6提供了一个全新的数据结构Set，它类似于数组，但是成员的值是唯一的，没有重复值

```Set```本身是一个构造函数，用来生成Set数据结构
```var s=new Set();```
<br>
```Set```函数允许接受一个数组作为参数，把数组数据格式转为Set数据格式，可以以此进行数组数据去重。同时Set结构也可以使用扩展运算符```...```来读取数据，也就是说只需要```[...Set数组]```就可以把Set数据格式变为数组格式

它还可以进行字符串去重：
```console.log([...new Set("aabbcccddd")].join(""));```
输出为abcd

向Set加入值的时候不会发生类型转换，1和"1"是两个不同的值

```size```属性可以返回```Set```实例的成员总数
```add()```方法向```Set```实例中添加元素
```delete()```方法删除```Set```实例中的某个值，返回一个布尔值表示是否删除
```has()```方法判断```Set```实例中是否具有某个值，返回布尔值
```clear()```方法清除```Set```实例的所有成员，没有返回值
* **
* ## Promise对象
Promise是异步编程的一种解决方法，比传统的解决方案（回调函数和事件）更合理和强大。ES6将器写进了语言标准，统一了用法，提供了```Promise```对象

```Promise```是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）。从语法上说```Promise```是一个对象，从它可以获取异步操作的消息。```Promise```提供统一的API，各种异步操作都可以用同样的方法进行处理

```Promise```对象是一个构造函数，用来生成```Promise```实例，它接受一个参数作为参数，该函数的参数分别是```resolve```和```reject```它们是两个函数，由JS引擎提供，不用自己部署

```Promise```实例生成后可以用```then```方法指定```resolved```和```rejected```状态的回调函数
```
promise.then(function(value){
成功
},function(error){
失败
});
```
以一个加载图片的函数为例子：
```
<div id="box1"></div>

<script>
var box1=document.getElementById("box1")
function jz(url){
    const promise=new promise(function(resolve，reject){      //因为promise对象一般再不修改，所以用const
        const image=new Image();
        image.src=url
        image.onload=function(){      //onload监听成功加载，如果成功就返回image
            resolve(image);
        }
        image.onerror=function(){
            reject(new Error(url+'错误'));    //onerror监听失败加载，失败就返回报错信息
        }
    })
    return promise;
}

const tupian=jz("");
tupian.then(function(data){       //data指的是上面返回的image标签
    box.appendChild(data);
},function(error){
    box.innerHTML='图片加载失败';
    console.log(error);          //在console里写入错误信息
})

</script>
```
<br>
Promise封装Ajax，让网络请求的异步操作变得简单
Ajax的介绍在图解HTTP笔记中有写

* **
* ## Class
ES6提供了更接近传统语言的写法，引入了Class（类）这个概念作为对象的模板。提供```class``关键字可以定义类：
```
class user{
    constructor(mz,nl){
    this.name=mz;
    this.num=nl
    }
    getname(){
    console.log(this.name);
    }
}
var p=new user("fuhuo",1234);
p.getname();
```
```constructor()```方法是类的默认方法，提供```new```命令生成对象实例时自动调用该方法，一个类必须要有```constructor()```方法，如果没有显式定义就会自动添加一个空的```constructor()```方法

类的实例生成一定要用```new```命令

实例属性指的是类的实例对象可以调用的属性，写在```constructor()```里面

类相当于实例的原型，所有在类中定义的方法都会被实例继承，如果在一个方法前加上```static```关键字就表示该方法不会被实例继承而是直接通过类来调用，这就叫做**静态方法**
```
class fuhuo{
    static dzh(){
    console.log("Hello");
    }
}
fuhuo.dzh()                 //Hello
var p=new fuhuo();
p.dzh()                     //p.dzh is not a function
```
如果静态方法包含```this```关键字，那么它指的是当前类而非实例对象

静态属性指的是Class本身的属性
```
class fuhuo{}
fuhuo.num=1234;
console.log(fuhuo.num);
```
<br>
Class可以通过```extends```关键字进行继承，让子类继承父类的属性和方法
```class 子类 extends 父类{}```
静态方法也是可以继承的，但是同样不能通过实例对象进行调用，可以像这样```子类.父类的静态方法()```进行调用

ES6规定子类必须在```constructor()```方法中调用```super()```，否则就会报错。这是因为子类自己的```this```对象必须先通过父类的构造函数完成塑造，得到和父类相同的实例属性和方法，然后对齐进行加工添加子类自己的实例属性和方法，如果不调用```super()```方法，子类就得不到自己的```this```对象
```
class zl extends fl{
    constructor(a,b,c){
    super(a,b);           //a,b是父类的属性，而且super()方法必须写在第一行
    this.name=c;
    }
    getname(){console.log(this.name);}
}
```
* **
* ## fetch
* ### fetch简介
在开发中要向服务器请求数据库时，可以用这些方法
* 方法一：通过Ajax向服务器请求数据，而Ajax的本质就是使用HMLHttpRequest对象实现的<br>
可以实现，就是代码有一点麻烦：
```
let xhr=new XHLHttpRequest()   //创建一个xhr对象
xhr.open('get','请求地址')   //设置请求方式和请求地址
xhr.send()   //发送请求
xhr.addEventListener('load',function(){  //监听load事件获取响应结果
    console.log(JSON.parse(xhr,response))
})
```
* 方法二，通过axios实现，代码要精简不少，但它底层还是基于XMLHttpRequest对象实现的，本质不变，只是进行了promise封装

那么有没有一种除了使用XMLHttpRequest发送请求之外的方式吗

有的，兄弟，有的，就是fetch

fetch被称之为下一代Ajax技术，内部采用Promise方法来处理数据（直接```.then```即可）。API语法简洁明了，比XMLHttpRequest更简单易用。采用了模块化设计，API分散在多个对象中（如：Response对象、Request对象、Header对象）。通过数据流（Stream对象）处理数据，可以分块读取，有利于提高网站性能，对于大文件或者网速慢的情况很有用

注意：fetch不兼容IE
* **
* ### 怎么使用fetch
如果```fetch()```只接受了一个url字符串参数，表示默认向该网站发送**get**请求，会返回一个Promise对象。如果需要设置get的参数，直接拼接到url上即可
```fetch('地址').then(res=>{console.log(res)})```
这里得到的res是一个Response对象，需要通过特定的方法来获取其中的内容

```res.json()```是一个异步操作，表示取出所有内容将其转换成JSON对象
```
fetch('地址')
    .then(res=>{return res.json() //返回经过json()方法处理后的值
        }).then(clh=>{console.log(clh)
            }).catch(cw=>{console.log(cw)   //捕获错误信息
                })
```
<br>

上面有很多的```.then```，也可以换一种写法
```
async function getData(){
   let res=await fetch('地址')   //先获取Response对象
   //然后需要通过json()方法取出Response对象中的结果
   let json=await res.json()
   console.log(json)
}
getData()
```
除此之外，还可以通过```try...catch```语法来处理async和await成功和失败的情况
```
async function getData(){
   try{
       let res=await fetch('地址')   //先获取Response对象
       //然后需要通过json()方法取出Response对象中的结果
       let json=await res.json()
       console.log(json)
       } catch(err){
       //请求失败时的情况
       console.log(err)
       }
}
getData()
```
按上面的方式写可以获得服务器的数据，但是是全体数据，如果像查询特定数据需要设置查询参数。其实只用把查询参数拼接在url上即可，格式为```url?属性名1=属性值&属性名2=属性值```

```async```是异步的意思，而```await```可以理解为```async await```。所有可以理解为```async```声明了一个异步方法，```await```等待异步方法的执行

```async```作为一个关键字放在函数前面，表示该函数是一个异步函数，异步函数意味着该函数的执行不会阻塞后续代码的执行，```await```用来等待一个异步方法执行完成

当函数内部执行到一个```await```语句的时候，如果语句返回一个promise对象，那么函数将会等待promise对象的状态变为resolve后再继续往下执行。并会阻塞该函数内后面的代码

所以这俩的作用就是将异步逻辑转化为同步顺序来书写，并且函数可以自动执行，就是为了优化```.then```链而开发出来的

```async```的用法和语法很简单，在函数前面加上该关键字表示它是异步的，下面的函数只有一个返回promise对象的作用：
```
async function timeout() {
     return 'hello world!'
 }
 timeout()
 console.log('我虽然在后面，但是先执行')
 ```
 ```async```关键字重要的是就是async函数执行会返回promise对象，并且把内部的值进行promise封装。如果promise对象通过```then```或者```catch```方法又注册了回调函数，那么async函数执行完了之后，注册的回调函数就会放到异步队列中等待执行

```await```关键字只能放在async函数里面，它不仅仅用于等promise对象，还可以等任意表达式，它后面是实际是可以接普通函数调用或者直接量的，但一般还是放一个返回promise对象的表达式，它等待promise对象执行完毕并返回结果

```await```等到了它要等的东西然后呢？

1. 如果等到的不是promise对象，那么```await```表达式的运算结果就是它等到的东西
2. 如果等到了一个promise对象，那么他会阻塞函数后面的代码，等着promise对象resolve，然后得到resolve的值，作为await表达式的运算结果

```await```的优势在于处理```.then```链，就像上面改写后的代码一样

（还有一个小细节async/await打包后的代码其实会比 promise 复杂很多， 当然这个是一个忽略不计得问题）
* **
* ### Response对象
fetch请求成功了之后，得到的是一个Response对象，它是对应服务器的HTTP响应

常见属性：
|属性|描述  |
|--|--|
| ```res.ok``` | 返回布尔类型表示请求是否成功 |
| ```res.status``` |返回状态码  |
| ```res.statusText``` | 返回状态的文本信息 |
| ```res.url``` |返回请求的url地址  |
<br>

常见方法：
|方法|描述  |
|--|--|
| ```res.json()``` | 得到JSON对象 |
| ```res.text()``` | 得到文本字符串 |
| ```res.blob()``` | 得到二进制Blob对象 |
| ```res.formData()``` | 得到FromData表单对象 |
| ```res.arrayBuffer()``` | 得到二进制ArrayBuffer对象 |
<br>

* **
* ### fetch配置参数
fetch的第一个参数是url，此外还可以接收第二个参数作为配置对象，可以自定义发出的HTTP请求，语法为：```fetch(url,options)```。以post为例


```
fetch(url,{
    method:'post',
    headers:{
    'content-Type':"数据格式"
    },
    body:'post请求体数据'
})
```
fetch发送post请求有多种格式，JSON格式较为常用
```
async function add{
let obj={
    name:'fuhuo',
    num:1234
    }
    let res=await fetch(url,{
    method:'post',
    headers{
    'content-Type':'application/json'
    },
    body:JSON.stringify(obj)
    })
    let json=await res.json()
    console.log(json);
}
```
* **
* ### fetch函数封装
原生fetch虽然已经支持promise了，相比XMLHttpRequest方式好用很多，但是参数还是要自己处理比较麻烦：

1. get、delete的请求参数需要在地址栏进行拼接
2. put patch post的请求参数要转json设置请求类

目标效果：
```
http({
    method:'xxx',
    url:'xxx',
    params:{...}  //查询参数
})   //发送get请求、delete请求
http({
    method:'xxx',
    url:'xxx',
    data{...}
})    //发送post、put、patch请求
```
 那么要达成这个效果就需要封装这个http函数：
 ```
 async function http(obj){ 
     //先将形参obj解构赋值
     let {method,url,params,data}=obj
     //params需要处理，转化成能拼接在url后面的格式
     //data需要处理，如果有需要写完整的代码headers
     let res
     if(params){
     let str=new URLSearchParams(params).toString()  //简单的固定写法，可以直接用
     url=url+'?'+str;
     }
     if(data){
     res=await fetch(url,{
        method:method,
        headers{
        'content-Type':'application/json'
        },
        body:JSON.stringify(data)
        })
    }else{
    res=await fetch(url)
    }
    return res.json();
 }
 ```
* **





