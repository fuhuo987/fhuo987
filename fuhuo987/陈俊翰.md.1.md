[TOC]

# 前言
这里是陈俊翰学习前端知识的相关笔记
我尽量保持一天一更
因为之前有看过视频所以前面会比较快
写笔记就当复习一遍了
笔记纯手打，错字致歉
* **
* **
# HTML
* ## HTML是一种标记语言  

标签有两种形式，分别为单标签和双标签
双标签如
 ```c
 <div></div>
 <h1></h1>
```
单标签如
```c
<img>
```
* **
* ## 标题标签 

标题标签是双标签
由大到小从h1到h6
<h1>1</h1>
<h2>2</h2>
<h3>3</h3>
<h4>4</h4>
<h5>5</h5>
<h6>6</h6>

标题标签自带加粗
标签的合理运用可以提高SEO
* **
* ## 图片标签 

图片标签是一种单标签，用```<img>```表示，一般打出来长这样```<img src="" alt="" title="" width="" height="">```。其中```src```属性表示路径，需要在这里输入图片的地址，```alt```属性表示图片无法显示时显示的替代文本，```height```和```width```是图片的高和宽，不过一般只输入一个，不然会导致图片变形，title属性表示鼠标悬停在图片上时显示的文字提示。

这里附上我实际写下来的代码作为示例
```c
<img src="283pro.png" alt="" class="283pro" width="400px" style="float: right;" title="点击进入283PRO">
```
因为图片和html文件在一个文件夹里所以直接写了名字。

这里又可以引出图片路径的三种形式，分别是：**<u>绝对路径</u>,<u>相对路径</u>,<u>网络路径</u>**

绝对路径是电脑盘符存储和访问的具体地址，就类似于```D:\wenjian\1234.png```

相对路径是指两者相对关系，如果两者在同一路径下可以直接访问
**1. 子级关系：```/```**
**1. 父级关系：```../```**
**1. 同级关系：```./```（可以省略）**

网络路径就需要写出具体的网络地址
* **
* ## 超文本链接

超文本链接用```<a></a>```表示，他可以是一个字一个词也可以是一个图像，可以通过点击这些内容来跳转到新的文档或者当前文档的某个部分，需要在其```href=“”```中填入跳转网页的地址。

链接将以<font color=Blue><u>蓝色带有下划线</u></font>的字体显示，访问过的链接显示为<font color=Purple><u>紫色带有下划线</u></font>,样式后期可以通过css修改。

比如，我想实现通过点击图片进入游戏的效果，我就可以通过```<a><img></a>```来做到，就像这样：
```
<a href="https://shinycolors.enza.fun/" target="_blank">
<img src="283pro.png" alt="" class="283pro" width="400px" style="float: right;" title="点击进入283PRO">
</a>
```
这里的```target```属性表示新的链接怎么打开，方便控制链接的行为
```_blank``` 链接在新窗口打开
```_parent``` 链接在父窗口打开
```_self``` 默认值，链接在当前窗口打开
```_top``` 在顶层窗口打开
* **
* ## 列表标签

列表标签分为有序列表和无序列表
有序列表通过```<ol><li></li></ol>```来实现
```
<ol>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
</ol>
```
<ol>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
</ol>
列表可以嵌套，可以在一个列表里嵌套另一个列表

```
<ol>
<li>这是一个有序列表</li>
<li>abcd
    <ol>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
    </ol>
</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
</ol>
```
<ol>
<li>这是一个有序列表</li>
<li>abcd
    <ol>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
    </ol>
</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
</ol>

与有序列表相似，无序列表通过```<ul><li></li></ul>```进行表示

```
<ul>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
</ul>
```
<ul>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
</ul>

无序列表常用于做导航效果
* **
* ## 块元素和行内元素

HTML5中元素分类更加细致，但这里还是按照块元素和行内元素来进行学习
| 块级元素 | 内联元素 |
|-----------|------------|
| 块元素会在页面中占据一行（自上而下垂直排列） | 行内元素只会占据自身大小 |
| 块元素可以设置```width```,```height```属性 | 设置这两个属性无效 |
| 一般块元素可以包含其他块元素 | 一般行内元素包含行内元素不包含块级元素|

常见的块级元素有
```div、form、h1~h6、p、table、ul```等等等等

常见的行内元素有
```a、b、em、span、strong```等等等等

还有一些行内块级元素（不换行但是能够识别宽高）
```button、img、input```等等等等
  
  页面布局时需要考虑各个元素的特点
* **
* ## html文件的一般格式

现在才想起来这个还没说。。。
在Visual Studio Code里新建一个html文件，输入 **!+回车键**时就会自动打出基本框架，大概长这样
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

</body>
</html>
```
```body```部分是文档的主体，也是用户可以直接看到的内容，```head```里面描述了文档的各种信息，也可以在head里```link```css文件（外部样式）或者写```<style></style>```（内部样式），这些放到下面css的笔记中。
* **
* **
# CSS
* ## 简介

CSS(Cascading Style Sheets)层叠样式表，又叫级联样式表，简称样式表，CSS文件的后缀名为```.css```。

css的目的是让网页更加美观一致

CSS的规则由两个主要部分构成：**选择器，一条或多条声明**
如
```
div{
background-color: blue;
width: 200px;
}
```
每条声明由属性和值构成，属性和值通过冒号分开。
* **
* ## CSS的引入方式

CSS有三种引入方式，分别为：**内联样式、内部样式、外部样式**

**内联样式（行内样式）**
通过在元素后面加上```style```属性来引入css。
```
<img src="283.png" alt="" id="bz" style="user-select: none;">
```
这里就通过内联样式引入了css，将```user-select```属性的值改为了```none```，使图片不可被用户选中。

内联样式不利于维护，尽量少用

**内部样式**
当单个文档需要特殊的样式时就可以使用```<style></style>```标签在文档头部定义内部样式表

**外部样式**
当样式需要用到多个页面时，外部样式表就是一个好选择，可以在外部建立一个css文件，然后再文档头部通过```<link>```标签来进行引入
```
<link rel="stylesheet" href="./css/style.css">

<link rel="stylesheet" href="./css/color.css">
```
需要注意的是优先级的问题，这个放到后面的笔记中进行讨论。
* **
* ## 选择器

在这一部分中讨论css语法规则的一个主要部分：**选择器**

**全局选择器**
可以和任何元素匹配，优先级最低，一般做样式初始化
```
*{
    margin: 0;
}
```
<br>

**元素选择器**
选择文档中的元素，如``` p、div、img ```等等等等，可以描述这些元素的共性

```
table {
    margin-right: auto;
    margin-left: auto;
    border-collapse: collapse;
    table-layout:auto;
}
```
<br>

**类选择器**
相当灵活的选择器，首先先要通过```class```属性定义类，然后通过```.类名```来选择这一个类。注意类名不能以数字开头，同一个标签可以有多个类，通过空格隔开
```
.xz1{
    box-shadow:5px 8px 20px black ;
}
```
这个就是通过类选择器来给元素添加阴影的例子

**ID选择器**
与类选择器类似，需要先给元素定义一个```id```然后通过```#id名```进行选择，注意id尽量不要重复，同样也不能以数字开头

**合并选择器**
有些时候我们想同时选择多个元素，就可以用合并选择器的语法来减少重复代码，选择器之间用逗号隔开
```
table,th{
    border-collapse: collapse;
    border:2px solid black;
}
```
<br>

**选择器的优先级**
css中权重用数字衡量
元素选择器权重：1
类选择器权重：10
id选择器权重：100
内联样式：1000
如果是相同的样式，高权重的会覆盖低权重。

**关系选择器**
关系选择器分为**后代选择器、子代选择器、相邻兄弟选择器、通用兄弟选择器**

1. 后代选择器
选择所有被A包含的B元素用空格隔开
语法为```A B｛｝```
```
#background .jianjie {
    background: rgba(255, 255, 255, 0.5);
    width: 800px;
    margin-left: auto;
    margin-right: auto;
    margin-top: 50px;
}
```
2. 子代选择器
选择E元素的直接子元素F，对更深一层的元素不起作用，用>表示
语法为```E>F{}```

3. 相邻兄弟选择器
选择<u>**紧跟在E元素后**</u>的F元素，用+表示，语法为```E+F{}```

4. 通用兄弟选择器
选择**E元素之后的所有兄弟F元素**，用~表示，语法为```E~F{}```
* **
* ## 盒子模型

所有HTML元素都可以看作盒子，在css中“box model”这一术语是布局和设计时使用

css盒模型本质上是一个盒子，封装周围的HTML元素，它包括：
**外边距（margin）、边框（border）、内边距（padding）、实际内容（content）** 由外到内层层封装

1. margin外边距-清除边框外的区域，外边距是透明的
2. border边框-围绕在内边距和内容外的边框
3. padding内边距-清除内容周边区域，内边距是透明的
4. content实际内容-盒子内容，显示文字和图像

理解盒子模型可以帮助更好的布局网页
* **
* ## 一些常用属性

**字体属性** 
css字体属性定义字体、颜色、大小、加粗、文字样式
```                                                                                                                                                     
#background .box1 #biaoyucn {
    display: block;
    font-size: 50px;
    font-style: italic;
    font-family: "KaiTi";
    text-align: center;
    margin-top: 15px;
    margin-bottom: 0px;
}
```
<br>

**背景属性**
| 属性 | 描述 |
|-------|-------|
| ```background-color``` | 设置背景颜色|
|```background-image```|设置背景图片|
|```background-position```|设置背景图片显示位置|
|```background-repeat```|设置背景图片如何填充|
|```background-size```|设置背景图片大小|
<br>

**文本属性**
| 属性 | 描述 | 值|
|-------|-------|-----|
|```text-align``` | 指定元素文本的水平对齐方式|**left**:默认，文本居左排列；<br>**right**：文本排列到右边；<br>**center**：文本排列到中间|
|```text-decoration```|规定添加到文本的修饰|**underline**：下划线；<br>**overline**：上划线；<br>**line-through**：删除线|
|```text-transform```|控制文本大小写|**captialize**：每个字母开头大写；<br>**uppercase**：全部字母大写；<br>**lowercase**：全部字母小写|
|```text-indent```|规定文本块中首行字母的缩进|/|
<br>

**表格属性**
| 属性 | 描述 |
|-------|-------|
|``` border``` | 设置表格边框|
|```border-collapse```|设置表格边框是否被折叠成一个单一的边框或隔开|
|```width/height```|设置表格宽度/高度|
|```text-align```|设置表格中文本对齐属性|
|```color/background-color```|设置颜色/背景颜色|
<br>

* **
* ## 浮动

```float```属性定义元素在哪个方向浮动，任何元素都可以浮动

浮动只有左右浮动，没有上下浮动
浮动后的元素脱离了文档流，相当于ps里图层格外上加了一个图层，所以会出现折叠现象

当所有元素浮动的时候，会变成水平摆放，向左或向右，当容器不足时会在下一行摆放
* **
* ## 清除浮动
浮动的元素由于脱离了文档流，会导致其父元素高度塌陷，如果不想发生这种情况，就需要清除浮动带来的副作用

一般会用到四种方法

1. 父元素设置高度
给父元素设置```height```属性，将父元素撑开即可
2. 将受影响的元素增加```clear```属性
3. 如果父级塌陷，并且同级元素也受到了影响，可以在父级元素的样式里增加```overflow:hidden```，并在子级的样式里加```clear```属性
4. 通过伪元素的方法解决
在父标签添加伪类```after```，设置空的内容，并且使用```clear:both```注意父布局不设置高度
* **
* ## 定位

```position```属性指定了元素的定位类型
|值|描述|
|--|--|
|```relative```|相对定位|
|```absolute```|绝对定位|
|```fixed```|固定定位|
<br>

在设置定位之后可以使用```left、top、right、bottom```进行调整位置
**相对定位**
对象仍然处于常规的文档流中，但可以通过上面四个属性调整位置

**绝对定位**
对象脱离了文档流，此时偏移属性参照的是距离自身最近的定位祖先元素，如果没有定位的祖先元素，将追溯到```body```元素，每个绝对定位都像新开了一个图层，会出现覆盖情况，可以用```z-index```来调整

**固定定位**
与绝对定位相似，但偏移定位是以窗口为参考，用户滚动窗口时位置不变，具体应用就像广告栏和那种糊脸的广告

用好定位可以使界面更加美观，同时使模块发挥作用
* **
* ## 动画
动画可以使元素从一种样式逐渐变化为另一种样式

可以使用 **@keyframes** 来创建动画
```
@keyframes name{
    from|0%{
        css样式
    }
    percent{
        css样式
    }
    to|100%{
        css样式
    }
}
```
```name```：动画名称
```percent```：百分比值，可以添加多个

**animation执行动画**
```animation: name duration timing-function delay iteration-count direction;```
|值|描述|
|---|---|
|```name```|动画名称|
|```duration```|动画持续时间|
|```timing-function```|设置动画的速率|
|```delay```|设置动画的开始时间|
|```iteration-count```|动画循环次数，infinite为无限次循环|
|```direction```|播放方向|
|```animation-play-state```|控制动画的播放状态：running表示播放，paused表示暂停|
<br>

|timing-function的值|描述|
|----|----|
|```ease```|默认，逐渐变慢|
|```linear```|匀速|
|```ease-in```|加速|
|```ease-out```|减速|
|```ease-in-out```|先加速后减速|
<br>

|direction的值|描述|
|----|----|
|```normal```|默认，向前播放|
|```alternate```|偶数次向前播放，奇数次反向播放|
* **
* ## css嵌套

css嵌套使样式表更加容易阅读、模块化，同时也更容易维护，因为不需要重复选择器，文件同样可以被压缩

1.**子选择器**
可以使用css嵌套来创建一个父级的子选择器，这可以用来选择特定父元素的子元素，使用```&```来实现

有几个特定环境可以使得`` `&``` 嵌套选择器变得很必要或者有用：

-   在连接选择器时，如组合选择器或伪类
-   为了向后兼容。
-   作为一个辅助阅读的标志。当你看到 ```&``` 时，你就知道这里用到 CSS 嵌套了。
```
/* 不使用嵌套选择器 */
parent {
  /* 父样式 */
  child {
    /* 父级的子样式 */
  }
}

/* 使用嵌套选择器 */
parent {
  /* 父样式 */
  & child {
    /* 父级的子样式 */
  }
}

/* 浏览器均会把以上两个样式表解析为 */
parent {
  /* 父样式 */
}
parent child {
  /* 父级的子样式 */
}
```
2.**关系选择器**
css关系选择器也可在使用或不使用```&```嵌套选择器的情况下使用

```
h2 {
  color: tomato;
  + p {
    color: white;
    background-color: black;
  }
}
```
如果使用```&```嵌套选择器，只需在```+```前面加个```&```即可

3.**组合选择器**
与关系选择器不同，在使用组合选择器时，必须使用```&```嵌套选择器，这是因为浏览器会自动在不使用```&```嵌套选择器的选择器之间添加空格
```
.a {
  /* 带有 class="a" 元素的样式 */
  .b {
    /* 带有 class="b"，且为 class="a" 元素的子元素的样式 */
  }
  &.b {
    /* 带有 class="a b" 元素的样式 */
  }
}

/* 浏览器会将其分析为 */
.a {
  /* 带有 class="a" 元素的样式 */
}
.a .b {
  /* 带有 class="b"，且为 class="a" 元素的子元素的样式 */
}
.a.b {
  /* 带有 class="a b" 元素的样式 */
}
```

4.**后附嵌套选择器**
```&```嵌套选择器可以放到一个选择器的后方，这样可以反转上下文
```
.foo {
  /* .foo 的样式 */
  .bar & {
    /* .bar .foo 的样式 */
  }
}
```
<br>

如果一个嵌套 CSS 规则无效，那么所有其包含的样式都将被忽略。这不影响其父级及其后面的规则。

使用css嵌套可以将包含任何样式的at规则嵌入到另一个规则中。嵌套在at规则从距离它们最近的祖先规则中获得选择器定义

可以被嵌套的at规则有：

1. ```@media```
2. ```@support```
3. ```@layer```
4. ```@scope```
5. ```@container```

以```@media```为例，使用at规则嵌套的css为：
```
.foo {
  display: grid;
  @media (orientation: landscape) {
    grid-auto-flow: column;
  }
}
```
此时浏览器解析嵌套块是这样的：
```
.foo {
  display: grid;
  @media (orientation: landscape) {
    & {
      grid-auto-flow: column;
    }
  }
}
```
如果不使用at嵌套，那么它的等价表示是：
```
.foo {
  display: grid;
}

@media (orientation: landscape) {
  .foo {
    grid-auto-flow: column;
  }
}
```

at规则也可以嵌套其他at规则，如：
```
.foo {
  display: grid;
  @media (orientation: landscape) {
    grid-auto-flow: column;
    @media (min-width: 1024px) {
      max-inline-size: 1024px;
    }
  }
}
```
如果不使用嵌套的方法，它的等价表示是这样：
```
.foo {
  display: grid;
}
@media (orientation: landscape) {
  .foo {
    grid-auto-flow: column;
  }
}
@media (orientation: landscape) and (min-width: 1024px) {
  .foo {
    max-inline-size: 1024px;
  }
}
```
<br>

**嵌套的优先级**
```&```嵌套选择器的优先级由它所关联的选择器列表中优先级最高的选择器决定
```
<b class="foo">
  <c>蓝色文字</c>
</b>
```
```
#a, b {
  & c {
    color: blue;
  }
}

.foo c {
  color: red;
}
```
在这个示例中，ID 选择器（```#a```）的优先级是 ```1-0-0```，而类型选择器（```b```）的优先级是 ```0-0-1```。```&``` 嵌套选择器有 ```1-0-0``` 的优先级，尽管 ID 选择器 ```#a``` 从未使用。

类选择器 ```.foo``` 的优先级是 ```0-1-0```。经过计算得出，```& c``` 的总优先级是 ```1-0-1```，而 ```.foo c``` 的优先级是 ```0-1-1```，意味着 ```color: blue;``` 是最后赢家

在使用嵌套选择器的时候要注意优先级问题
*  **
* ## At规则
由于上文提到了at规则，于是在这里再做一下笔记

at规则是一个css语句，用来指示css如何运行，以```@```开头后跟一个标识符，并包括直到下一个分号的所有内容，或下一个 CSS 块，以先到者为准

下面是一些不同的at规则：
| 名称 |描述 |
|--|--|
|```@charset``` | 定义样式表使用的字符集|
| ```@import``` |告诉 CSS 引擎引入一个外部样式表 |
| ```@namespace``` | 告诉 CSS 引擎必须考虑 XML 命名空间 |
<br>

嵌套 at 规则，是嵌套语句的子集，不仅可以作为样式表里的一个语句，也可以用在条件规则组里：
| 名称 |描述  |
|--|--|
| ```@media``` |如果满足媒介查询的条件则条件规则组里的规则生效  |
|```@supports```  | 如果满足给定条件则条件规则组里的规则生效 |
|```@document```  |如果文档样式表满足给定条件则条件规则组里的规则生效  |
|``` @page``` | 描述打印文档时布局的变化 |
| ```@font-face``` | 描述将下载的外部的字体 |
| ```@keyframes``` | 描述 CSS 动画的中间步骤 |
| ```@layer```| 声明一个级联层，并在有多个级联层时定义优先顺序。|
<br>

**条件规则组**
每条at规则都有不同的语法，但一些at规则可以被归为一个特殊的分类：条件规则组。它们都使用相同的语法，它们都表达：它们所指的条件 (类型不同) 总等效于 **true** 或者 **false**，如果为 **true** 那么它们之中的语句生效。如```@media```、```@supports```、```@document```
* **
* ## 媒体查询

媒体查询可以使页面在不同终端下显示不同效果，会根据设备的大小自动识别加载不同的样式

**设置```meta```标签**
在```<head>```里加入这个```meta```标签能将使用设备的宽度作为初始宽度并禁止初始缩放
```
<meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1,user-scalable=no">
```
1. ```width=device-width```宽度等于当前设备的宽度
2. ```initial-scale=1.0```初始的缩放比例（默认1.0）
3. ```maximum-scale=1```允许用户缩放到的最大比例（默认1.0）
4. ```user-scalable=no```用户是否可以手动缩放 (默认是no）

```
@media screen and(max-width:768px)
/*设备小于768px加载样式 */
    body{}
}
@media screen and(max-width: 992px)and(min-width:768px){
/*设备小于768px但小于992px加载样式 */
    body{}
}
@media screen and(min-width:992px){
/*设备大于992px加载样式*/
    body{}
}
```
* ## flex布局
Flexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。

之所以称flexbox是一种一维的布局，是因为它不像grid布局一样可以同时处理行和列，它一次只能处理一行或者一列上的元素布局。

flexbox有两根轴线：**主轴**和**交叉轴**，主轴由```flex-direction```定义，可以取以下四个值：

1. ```row```（默认）
2. ```row-reverse```
3. ```column```
4. ```column-reverse```

有```-reverse```的相比没有的起始线和终止线相反![输入图片说明](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox/basics5.svg)

选择```row```或```row-reverse```主轴按行的方向延伸，反之主轴将上下延伸

交叉轴垂直于主轴

flex容器有多种属性：
|属性  |值  |描述|
|--|--|----|
|```flex-direction```|**row（默认）<br> row-reverse column<br> column-reverse**  | 改变flex元素的排列方向    |
|```flex-wrap```| **wrap <br>nowrap（默认）** | 项目太大无法显示在一行中时换行显示    |
|```align-items```|**stretch**(默认，元素拉伸到最高元素的高度)<br> **flex-start**(顶部对齐) <br>**flex-end**(底部对齐) <br>**center**(居中对齐)|使元素在交叉轴方向对齐|
|```justify-content```|**flex-start**(默认，元素从起始线排列)<br> **flex-end**(从终止线开始排列) <br>**center**(在中间排列)<br> **space-around**(元素之间间隔相等)<br> **space-between**(元素的左右空间相等)|使元素在主轴方向上对齐|
|```align-content```|**flex-start**(与交叉轴的起点对齐)<br>**flex-end**(与交叉轴的终点对齐) **center**(与交叉轴的中点对齐) <br> **space-between**(与交叉轴两端对齐，轴线之间的间隔平均分布) <br>**space-around**(每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍) <br>**stretch**(默认值，轴线占满整个交叉轴)|定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用|
<br>

```flex-direction```和```flex-wrap```这两种属性可以合并写为```flex-flow: 值1 值2```,第一个指定的值为 ```flex-direction``` ，第二个指定的值为 ```flex-wrap```

flex元素也有多种属性：

|属性|描述  |
|--|--|
|```flex-grow```  | 定义了在有可用空间时的放大比例 |
| ```flex-shrink``` | 定义了在空间不足时的缩小比例 |
|```lex-basis```  | 指定了项目在分配空间前的初始大小 |
<br>

这几个flex属性的作用其实就是改变了flex容器的可用空间的行为（在把flex项目用到多行的时候，应该把每一行都看作一个新的flex容器），这三个属性可以合并成```flex: 值1 值2 值3```，三个值分别对应```flex-grow```，```flex-shrink```，```flex-basis```

大多数情况下用预定义的简写形式
| 简写 | 相当于 |
|--|--|
|```flex: auto```  | ```flex: 1 1 auto ```|
|```flex: initial```  | ```flex: 0 1 auto ```|
|```flex: none```  | ```flex: 0 0 auto``` |
| ```flex: 1``` | ```flex: 1 1 0``` |
| ```flex: 2``` | ```flex: 2 1 0``` |
|```flex: num```|```flex: num 1 0```


* **
* ## grid布局

grid布局即网格布局，引入了二维网格布局系统

网格是一组相交的水平线和垂直线，它定义了网格的行和列，可以把网格元素放在这些行列相关的位置上

网格布局的特点有：

1. **固定的位置和弹性的轨道大小**：既可以使用固定的轨道尺寸创建网格，也可以使用百分比或者```fr```来创建有弹性尺寸的网格
2. **网格项摆放**：可以使用行号、行名或者标定一个网格区域来精确定位元素，同时还使用一种算法来控制未给出明确网格位置的元素
3. **创建额外的轨道来包含内容**：可以通过网格布局定义显式网格。网格布局规范非常灵活，可以在需要时添加额外的行和列。包括添加“一个容器能容纳的尽可能多的列”等特性
4. **对齐控制**：网格包含对齐特性，因此我们可以控制项目放入网格区域后的对齐方式，以及整个网格的对齐方式
5. **控制重叠内容**：多个项目可以放置在网格单元格中，或者区域可以部分地彼此重叠。然后可以使用 ```z-index``` 属性来控制重叠区域显示的优先级

通过在元素上声明```display: 	grid```来创建一个网格容器，里面的所有直系子元素都将成为网格项目

使用 ```grid-template-rows```和 ```grid-template-columns```属性定义网格上的行和列。这些属性定义了网格轨道。_网格轨道_（grid track）是网格上任意两条相邻线之间的空间。

轨道可以使用任何长度单位进行定义，也可以使用一个新单位```fr```来定义轨道大小，也可以混合使用单位如```grid-template-columns: 500px 1fr 2fr;```就是在可用空间扣除了500px宽度后再一分为三按比例分配

包含多个轨道的大型网格可使用 ```repeat()``` 标记来重复部分或整个轨道列表，如```grid-template-columns: 1fr 1fr 1fr;```就可以写成```grid-template-columns: repeat(3,1fr);```。同时```repeat()```也可以重复轨道列表中的一部分。如果是```repeat(5,1fr,2fr)```就意味着网格有十个轨道，为1个```1fr```后面跟着一个```5fr```，这样重复五次

如果希望行或列的大小永远不会小于一个值时，可以使用```minmax()```函数，如 ``` grid-auto-rows: minmax(100px, auto);```就意味着行高度最小为100px，最大为auto，使用 auto 表示大小将取决于内容的大小，并将拉伸以在该行中为单元格中最高的项目留出空间。

在定义网格时，定义的是网格轨道而非网格线，一个三行两列的网格中有四条纵向的网格线，网格线的编号顺序取决于文章的书写格式，网格线也可以被命名

使用 ```grid-column-start```、```grid-column-end```、```grid-row-start``` 和 ```grid-row-end``` 属性可以将项目放到自己想要的位置，也可以跨轨道放置，注意目标是网格线而不是网格轨道。这个有简写，如：```grid-column```和```grid-row```，值为 ```值1/值2```，值1为起始网格线，值2为终止网格线，也可以更进一步，合并为```grid-area```属性，同样用```/```分开，值的顺序为```grid-row-start```/```grid-column-start```/```grid-row-end```/```grid-column-end```

项目可以按行或者列跨越一个或多个单元格，形成了一个*网格区域*，网格区域必须是矩形的

网格单元格之间的横向间距或纵向间距可以使用```column-gap```和```row-gap```属性（简写为```gap```）

网格间距使用的任何空间都会在分配给灵活长度的 ```fr``` 轨道之前计算在内，而且网格间距的大小与常规网格轨道相同，但不能在间距中放置任何东西。就基于行的定位而言，网格间距就像一条粗线。

网格也可以嵌套，将一个网格项作为一个网格容器，如果不使用子网格的嵌套，那么嵌套网格和父网格没有任何关系，不会继承父网格的属性

*子网格*(subgrid)能让在创建嵌套网格的同时使用父网格的轨道定义，如将 ```grid-template-columns: repeat(3,1fr)```的轨道定义更改为 ```grid-template-columns: subgrid```。嵌套网格就会沿用父网格轨道来布局项目。

网格项可以占据同一单元格，可以使用```z-index```属性改变堆叠顺序（这里好像和绝对定位挺像的），就是当一个单元格被两个网格区域覆盖时就可以改变```z-index```的值决定谁在上面

在抉择布局方式时，应该思考是**只需要按行或者列布局**还是要**同时按行和列布局**，以此决定使用弹性盒子布局还是网格布局

css的网格布局是一种很好用的工具，应该大胆尝试与其他布局方法混用，获得想要的页面效果
* **
 * # JavaScript
 *  ## 简介
 
JavaScript是一种轻量级的脚本语言，所谓脚本语言，就是指它不具备开发操作系统的能力，只用来编写其他大型应用程序的脚本

JavaScript是一种嵌入式语言，它本身提供的核心语法不算很多

*  **
* ## JavaScript的语句和标识符
JavaScript程序单位是行，一般情况下一行就是一个语句，语句以分号结尾，一个分号表示一个语句结束

标识符指的是用来识别各种值的合法名称，最常见的就是各种变量名称，注意不能以数字开头
* **
* ## JavaScript引入方式
和css类似，JavaScript也有三种常用引入方式：

1. 嵌入到html文件中
用```<script></script>```标签包含js代码
2. 引入本地js文件
语法如```<script src="./js/1.js"></script>```在```src```里写入js文件的地址即可
3. 引入网络来源文件
即在```<script src=""></script>```的```src```里填入网络来源的js文件地址


* **
* ## 常用运算符
**typeof运算符**
JavaScript有三种方法可以确定一个值是什么类型，最先接触到的是```typeof```

1. 数值返回number
2. 字符串返回string
3. 布尔值返回boolean
4. 对象返回object
5. 没有数值返回undefined
<br>

**算数运算符**
| 运算符 | 描述 |
|--|--|
| ```+``` | 加 |
|``` -``` | 减 |
|``` * ```| 乘 |
| ```/``` | 除 |
|``` % ```| 取余 |
| ```p++``` | 先运算再自增 |
|``` ++p ```| 先自增再运算 |
<br>

**赋值运算符**
| 运算符 | 描述 |
|--|--|
|``` = ```| 赋值运算符 |
|``` +=``` | x+=y等同于x=x+y |
| ```-= ```| x-=y等同于x=x-y |
| ```/= ```| x/=y等同于x=x/y|
|``` *=``` | x*=y等同于x=x*y |
| ```%=``` | x%=y等同于x=x%y |
<br>

**比较运算符**
| 运算符 | 描述 |
|--|--|
|```<``` | 小于 |
| ```>``` | 大于 |
|``` <=``` | 小于等于 |
| ```>=``` | 大于等于 |
|``` ==``` | 相等 |
| ```===``` | 严格相等 |
| ```!= ```| 不等于 |
| ```!==``` | 严格不等于 |
<br>

**布尔运算符**
| 运算符 | 描述 |
|--|--|
|``` ! ```| 取反 |
| ```&&``` | 且 |
| ```||``` | 或 |
 * **
 *  ##条件语句
 
 **if语句**
 if语句先判断一个表达式的布尔值，然后根据布尔值的真伪执行不同的语句，语法如下：
 ```if(flag){要执行的语句}```
 
 **if...else语句**
 if代码块后面可以跟一个else代码块，表示不满足条件时要执行的代码，语法如下：
  ```
  if(flag){
        要执行的语句
    }else{
        要执行的语句
    } 
```
如果在不同条件下要执行不同的代码，可以使用if...else if...else语句，else if可以任意多，语法如下：
```
  if(flag){
        要执行的语句
    }else if(flag2){
        要执行的语句
    }else{
        要执行的语句
    } 
```
<br>

**switch语句**
在有多种选择的情况下也可以考虑使用switch语句，注意的是每一个```case```最后都要有一个```break```，否则会继续执行下一个case代码块，语法如下：
```
   switch(变量){
       case 值1:
           代码块
           break;
       case 值2:
           代码块
           break;
       case 值3:
           代码块
           break;
       default:
           代码块
   }
```
* **
* ## 循环语句
循环语句就是重复执行某个操作

**for语句**
for语句就是循环命令，可以指定循环的起点、终点和终止条件，语法如下：
```
for(初始化表达式;条件;循环因子){
    要循环的语句
    }
```
其中初始化表达式只在循环开始时执行一次，条件每轮循环开始时都要执行一遍，只有布尔值为真时才执行此次循环，循环因子是每轮循环的最后一次操作，通常用来递增循环变量

** while语句**
while语句包含一个循环条件和代码块，只要条件为真就执行代码块，直到条件为假时或遇到```break```跳出循环，语法如下：
```
while(条件){要循环的语句}
```
需要注意的是在语句内应该有改变与条件有关变量的语句或```break```语句，防止出现死循环

所有for循环都可以写成while循环，反之亦然

循环语句可以嵌套，通过循环语句嵌套可以实现想要实现的效果

**break语句和continue语句**
```break```和```continue```都可以让代码不按原有的顺序进行

```break```语句用于跳出代码块或者循环，遇到```break```意味着循环的结束

```continue```语句意味着立刻终止本轮循环，返回循环体的头部，开始下一轮循环
 *   **
 *  ## 字符串

字符串就是零个或多个排在一起的字符放在单引号和双引号之中

单引号可以嵌套双引号，双引号可以嵌套单引号，但不能相同引号嵌套。如果要使用相同引号嵌套，就得在引号前添加```\```用来转义

字符串默认只能一行显示，如果要换行需要转义

**charAt**通过输入的下标数字传递相应的字符，如果参数为负数或大于等于字符串的时候，它返回空字符

**concat**用来合并两个字符串，返回一个新字符串，不改变原字符串，语法为```str1.concat(str2)```，将str2合并到str1后面。参数可以有多个（用逗号隔开），如果参数不是字符串，会将参数先转化为字符串再拼接

连接字符串可以不用```concat```，用```+```连接效果一样还简单。但是```concat```完全不会做运算，如果是```+```的话，两个数字会做加法运算而不是转化为字符串连接，只有遇到字符串才会转化为字符串

**substring**是用来截取字符串的方法，从原字符串取出子字符串并返回，不改变原字符串。两个参数分别是首位置下标和末位置下标，但是不包含末位置。（就是字符串切片的方法）

第二个参数不写默认到原字符串结尾，如果第一个参数大于第二个参数它会自动更改两个参数位置。如果参数是负数，它会自动把参数转化为0

**substr**和```substring```作用差不多，都是从原字符串取出子字符串并返回，不改变原字符串。第一个参数是首位置下标，第二个参数是子字符串的长度

如果省略第二个参数就会一直到原字符串的结束。第一个参数如果是负数，表示倒数计算的字符位置；第二个参数如果是负数就会被自动转化成0，最后返回空字符串

**indexOf**方法用来确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始时的位置，如果不匹配就返回```-1```

该方法还能接受第二个参数，表示从该参数位置后进行查找

**trim**用来去掉字符串两端的空格，返回一个新字符串，不改变原字符串

它不仅能去除空格，还能取出制表符（```\t```、```\v```）、换行符（```\n```）回车符（```\r```）

ES6还新增了```trimEnd```和```trimStart```方法，一个去尾部一个去头部

**split**方法用来按给定规则分割字符串，返回一个由分割字符串组成的数组

如果分割规则是空字符，那么数组的成员就是每一个字符
如果省略参数，那么数组的唯一成员就是原字符串

该方法还能接收第二个参数，限定返回数组的最大成员数
 * **
 * ## 数组

**数组**是按次序排列的一组值，每个值都有编号，整个数组用方括号表示。两端的方括号是数组的标志，任何类型的数据都能被放入数组。可以用```length```属性返回数组的成员数量

数组的遍历可以用for循环或者while循环

还有```for...in```遍历数组，格式如下
```
for(var i in a){
    console.log(a[i]);
}
```
<br>

**Array.isArray** 可以判断对象是不是数组，它可以弥补```typeof```的不足

**push**用来在数组的**末端**添加一个或多个元素，并返回添加后新数组的长度，该方法会改变数组

**pop**方法用来删除数组的**最后一个元素**并返回该元素，该方法同样会改变数组

**shift**方法用来删除数组的**第一个元素**并返回该元素，该方法会改变数组

**unshift**方法用来在数组的**首端**添加一个或多个元素，并返回添加后新数组的长度，该方法会改变数组

**join**方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回，没有指定参数默认以逗号分隔

如果数组成员是```undefined```或者```null```，会被转为空字符串

```join```和```split```可以实现数组和字符串的互换

**concat**不止用来合并字符串，也可以将一个数组的成员添加到原数组的后面，返回一个新数组，原数组不变。除了将数组作为参数，也可以将其他类型的值作为参数添加到目标数组后面

**reverse**方法用来颠倒数组元素并返回改变后的数组，会改变原数组

**indexOf**方法也可以对数组使用，效果一样，但是查找的是给定元素在数组里第一次出现的位置

* **
* ## 函数

函数由```function```命令来进行声明，function命令声明的代码区块就是一个函数，```function```后面跟着函数名，函数名后面是括号，里面包含着传入函数的参数，函数体在后面的大括号里面

函数可以先调用再创建，因为函数会自动提升到代码头部

函数用```return```将值返回给外界
 * **
 * ## 对象
对象是JS的核心概念，也是重要的数据类型，它是一组键值对的集合，是一种无序的复合数据集合，形如：
```
var user={
    name:'fuhuo',
    num: 1234
};
```
对象的每一个键名又称为**属性**，它的键值可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为**方法**，它可以像函数一样被调用

如果属性的值还是对象，就形成了链式引用

对象的读取方式是通过```对象名.属性```来进行调用
 * **
 * ## Math对象
Math是JS的原生对象，提供各种数学功能
|对象名|功能  |
|--|--|
| ```Math.abs()``` | 返回参数的绝对值 |
| ```Math.max()/Math.min()``` | 返回参数之中的最大值/最小值 |
| ```Math.floor()/Math.ceil``` | 返回小于/大于参数的最大整数 |
| ```Math.random()``` | 返回0~1之间的一个伪随机数，可能为0但一定小于1 |

* **
* ## Date对象

```Date.now()```返回当前时间距离时间零点（1970年1月1日 00：00：00UTC）的毫秒数

Date对象提供了一系列get方法，用来获取实例对象某个方面的值
|方法|描述  |
|--|--|
| ```getTime()``` | 返回实例距离1970年1月1日 00：00：00的毫秒数 |
| ```getDate()``` | 返回实例对象对应每个月的几号 |
| ```getDay()``` | 返回星期几，星期日为0，星期一为1 |
| ```getYear()``` | 返回距离1900的年数 |
| ```getFullYear()``` | 返回四位的年份 |
| ```getMonth()``` | 返回月份（0是1月） |
| ```getHours()``` | 返回小时（0~23） |
| ```getMilliceconds``` | 返回毫秒（0~999） |
| ```getMinutes``` | 返回分钟（0~59） |
| ```getSeconds``` | 返回秒（0~59） |

 * **
 * ## DOM
DOM是JS操作网页的接口，全称为“文档对象模型”（Documm Object Model），它的作用是将网页转为一个JS对象，从而可以用脚本进行各种操作

浏览器会根据DOM模型将结构化文档HTML解析成一系列节点，再由这些节点组成一个树状结构（DOM Tree），所有的节点和最终的树状结构都有规范的对外接口

DOM只是一个接口规范，可以用各种语言实现，但DOM操作是JS的常见任务，离开了DOM，JS就无法操作控制网页，JS也是最常用于DOM操作的语言

DOM的最小组成单位叫做**节点**，文档的树形结构就是由不同的节点组成，每个节点都是文档树的一片叶子

节点有七种类型：

|节点| 描述 |
|--|--|
|**Document** | 整个文档树的顶层节点 |
|**DocumentType** | doctype标签 |
|**Element** | 网页的各种HTML标签 |
|**Attribute** | 网页元素的属性（如class=“abcd”） |
|**Text** | 标签之间或标签包含的文本 |
|**Comment** | 注释 |
|**DocumentFragment** | 文档的片段 |

**节点树：** 一个文档的所有节点按照所在的层级可以抽象成一种树状结构，这就是DOM树，它有一个顶层节点，下一层都是顶层节点的子节点，子节点也有自己的子节点，形成一个金字塔型结构，倒过来就像一棵树

除了根节点，其他节点有三种层级关系：

1. **父节点关系：** 直接的上级节点
2. **子节点关系：** 直接的下级节点
3. **同级节点关系：** 拥有同一个父节点的节点

<br>

**Node.nodeType属性**不同节点的nodeType属性值和对应的常量如下：

| 节点 | 属性值 | 对应的常量 |
|--|--|--|
|**文档节点**  | 9 | Node。DOCUMENT_NODE |
|**元素节点**  | 1 | Node.ELEMENT_NODE |
|**属性节点**  | 2 | Node.ATTRIBUTE_NODE |
|**文本节点**  | 3 | Node.TEXT_NODE |
|**文档片段节点**  | 11 | Node.DOCUMENT_FRAGMENT_NODE |

