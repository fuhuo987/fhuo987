[TOC]

# 前言
这里是陈俊翰学习前端知识的相关笔记
我尽量保持一天一更
因为之前有看过视频所以前面会比较快
写笔记就当复习一遍了
笔记纯手打，错字致歉
* **
* **
# HTML
* ## HTML是一种标记语言  

标签有两种形式，分别为单标签和双标签
双标签如
 ```c
 <div></div>
 <h1></h1>
```
单标签如
```c
<img>
```
* **
* ## 标题标签 

标题标签是双标签
由大到小从h1到h6
<h1>1</h1>
<h2>2</h2>
<h3>3</h3>
<h4>4</h4>
<h5>5</h5>
<h6>6</h6>

标题标签自带加粗
标签的合理运用可以提高SEO
* **
* ## 图片标签 

图片标签是一种单标签，用```<img>```表示，一般打出来长这样```<img src="" alt="" title="" width="" height="">```。其中```src```属性表示路径，需要在这里输入图片的地址，```alt```属性表示图片无法显示时显示的替代文本，```height```和```width```是图片的高和宽，不过一般只输入一个，不然会导致图片变形，title属性表示鼠标悬停在图片上时显示的文字提示。

这里附上我实际写下来的代码作为示例
```c
<img src="283pro.png" alt="" class="283pro" width="400px" style="float: right;" title="点击进入283PRO">
```
因为图片和html文件在一个文件夹里所以直接写了名字。

这里又可以引出图片路径的三种形式，分别是：**<u>绝对路径</u>,<u>相对路径</u>,<u>网络路径</u>**

绝对路径是电脑盘符存储和访问的具体地址，就类似于```D:\wenjian\1234.png```

相对路径是指两者相对关系，如果两者在同一路径下可以直接访问
**1. 子级关系：```/```**
**1. 父级关系：```../```**
**1. 同级关系：```./```（可以省略）**

网络路径就需要写出具体的网络地址
* **
* ## 超文本链接

超文本链接用```<a></a>```表示，他可以是一个字一个词也可以是一个图像，可以通过点击这些内容来跳转到新的文档或者当前文档的某个部分，需要在其```href=“”```中填入跳转网页的地址。

链接将以<font color=Blue><u>蓝色带有下划线</u></font>的字体显示，访问过的链接显示为<font color=Purple><u>紫色带有下划线</u></font>,样式后期可以通过css修改。

比如，我想实现通过点击图片进入游戏的效果，我就可以通过```<a><img></a>```来做到，就像这样：
```
<a href="https://shinycolors.enza.fun/" target="_blank">
<img src="283pro.png" alt="" class="283pro" width="400px" style="float: right;" title="点击进入283PRO">
</a>
```
这里的```target```属性表示新的链接怎么打开，方便控制链接的行为
```_blank``` 链接在新窗口打开
```_parent``` 链接在父窗口打开
```_self``` 默认值，链接在当前窗口打开
```_top``` 在顶层窗口打开
* **
* ## 列表标签

列表标签分为有序列表和无序列表
有序列表通过```<ol><li></li></ol>```来实现
```
<ol>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
</ol>
```
<ol>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
</ol>
列表可以嵌套，可以在一个列表里嵌套另一个列表

```
<ol>
<li>这是一个有序列表</li>
<li>abcd
    <ol>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
    </ol>
</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
</ol>
```
<ol>
<li>这是一个有序列表</li>
<li>abcd
    <ol>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
        <li>这是另一个有序列表</li>
    </ol>
</li>
<li>这是一个有序列表</li>
<li>这是一个有序列表</li>
</ol>

与有序列表相似，无序列表通过```<ul><li></li></ul>```进行表示

```
<ul>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
</ul>
```
<ul>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
<li>这是一个无序列表</li>
</ul>

无序列表常用于做导航效果
* **
* ## 块元素和行内元素

HTML5中元素分类更加细致，但这里还是按照块元素和行内元素来进行学习
| 块级元素 | 内联元素 |
|-----------|------------|
| 块元素会在页面中占据一行（自上而下垂直排列） | 行内元素只会占据自身大小 |
| 块元素可以设置```width```,```height```属性 | 设置这两个属性无效 |
| 一般块元素可以包含其他块元素 | 一般行内元素包含行内元素不包含块级元素|

常见的块级元素有
```div、form、h1~h6、p、table、ul```等等等等

常见的行内元素有
```a、b、em、span、strong```等等等等

还有一些行内块级元素（不换行但是能够识别宽高）
```button、img、input```等等等等
  
  页面布局时需要考虑各个元素的特点
* **
* ## html文件的一般格式

现在才想起来这个还没说。。。
在Visual Studio Code里新建一个html文件，输入 **!+回车键**时就会自动打出基本框架，大概长这样
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

</body>
</html>
```
```body```部分是文档的主体，也是用户可以直接看到的内容，```head```里面描述了文档的各种信息，也可以在head里```link```css文件（外部样式）或者写```<style></style>```（内部样式），这些放到下面css的笔记中。
* **
* **
# CSS
* ## 简介

CSS(Cascading Style Sheets)层叠样式表，又叫级联样式表，简称样式表，CSS文件的后缀名为```.css```。

css的目的是让网页更加美观一致

CSS的规则由两个主要部分构成：**选择器，一条或多条声明**
如
```
div{
background-color: blue;
width: 200px;
}
```
每条声明由属性和值构成，属性和值通过冒号分开。
* **
* ## CSS的引入方式

CSS有三种引入方式，分别为：**内联样式、内部样式、外部样式**

**内联样式（行内样式）**
通过在元素后面加上```style```属性来引入css。
```
<img src="283.png" alt="" id="bz" style="user-select: none;">
```
这里就通过内联样式引入了css，将```user-select```属性的值改为了```none```，使图片不可被用户选中。

内联样式不利于维护，尽量少用

**内部样式**
当单个文档需要特殊的样式时就可以使用```<style></style>```标签在文档头部定义内部样式表

**外部样式**
当样式需要用到多个页面时，外部样式表就是一个好选择，可以在外部建立一个css文件，然后再文档头部通过```<link>```标签来进行引入
```
<link rel="stylesheet" href="./css/style.css">

<link rel="stylesheet" href="./css/color.css">
```
需要注意的是优先级的问题，这个放到后面的笔记中进行讨论。
* **
* ## 选择器

在这一部分中讨论css语法规则的一个主要部分：**选择器**

**全局选择器**
可以和任何元素匹配，优先级最低，一般做样式初始化
```
*{
    margin: 0;
}
```
<br>

**元素选择器**
选择文档中的元素，如``` p、div、img ```等等等等，可以描述这些元素的共性

```
table {
    margin-right: auto;
    margin-left: auto;
    border-collapse: collapse;
    table-layout:auto;
}
```
<br>

**类选择器**
相当灵活的选择器，首先先要通过```class```属性定义类，然后通过```.类名```来选择这一个类。注意类名不能以数字开头，同一个标签可以有多个类，通过空格隔开
```
.xz1{
    box-shadow:5px 8px 20px black ;
}
```
这个就是通过类选择器来给元素添加阴影的例子

**ID选择器**
与类选择器类似，需要先给元素定义一个```id```然后通过```#id名```进行选择，注意id尽量不要重复，同样也不能以数字开头

**合并选择器**
有些时候我们想同时选择多个元素，就可以用合并选择器的语法来减少重复代码，选择器之间用逗号隔开
```
table,th{
    border-collapse: collapse;
    border:2px solid black;
}
```
<br>

**选择器的优先级**
css中权重用数字衡量
元素选择器权重：1
类选择器权重：10
id选择器权重：100
内联样式：1000
如果是相同的样式，高权重的会覆盖低权重。

**关系选择器**
关系选择器分为**后代选择器、子代选择器、相邻兄弟选择器、通用兄弟选择器**

1. 后代选择器
选择所有被A包含的B元素用空格隔开
语法为```A B｛｝```
```
#background .jianjie {
    background: rgba(255, 255, 255, 0.5);
    width: 800px;
    margin-left: auto;
    margin-right: auto;
    margin-top: 50px;
}
```
2. 子代选择器
选择E元素的直接子元素F，对更深一层的元素不起作用，用>表示
语法为```E>F{}```

3. 相邻兄弟选择器
选择<u>**紧跟在E元素后**</u>的F元素，用+表示，语法为```E+F{}```

4. 通用兄弟选择器
选择**E元素之后的所有兄弟F元素**，用~表示，语法为```E~F{}```
* **
* ## 盒子模型

所有HTML元素都可以看作盒子，在css中“box model”这一术语是布局和设计时使用

css盒模型本质上是一个盒子，封装周围的HTML元素，它包括：
**外边距（margin）、边框（border）、内边距（padding）、实际内容（content）** 由外到内层层封装

1. margin外边距-清除边框外的区域，外边距是透明的
2. border边框-围绕在内边距和内容外的边框
3. padding内边距-清除内容周边区域，内边距是透明的
4. content实际内容-盒子内容，显示文字和图像

理解盒子模型可以帮助更好的布局网页
* **
* ## 一些常用属性

**字体属性** 
css字体属性定义字体、颜色、大小、加粗、文字样式
```                                                                                                                                                     
#background .box1 #biaoyucn {
    display: block;
    font-size: 50px;
    font-style: italic;
    font-family: "KaiTi";
    text-align: center;
    margin-top: 15px;
    margin-bottom: 0px;
}
```
<br>

**背景属性**
| 属性 | 描述 |
|-------|-------|
| ```background-color``` | 设置背景颜色|
|```background-image```|设置背景图片|
|```background-position```|设置背景图片显示位置|
|```background-repeat```|设置背景图片如何填充|
|```background-size```|设置背景图片大小|
<br>

**文本属性**
| 属性 | 描述 | 值|
|-------|-------|-----|
|```text-align``` | 指定元素文本的水平对齐方式|**left**:默认，文本居左排列；<br>**right**：文本排列到右边；<br>**center**：文本排列到中间|
|```text-decoration```|规定添加到文本的修饰|**underline**：下划线；<br>**overline**：上划线；<br>**line-through**：删除线|
|```text-transform```|控制文本大小写|**captialize**：每个字母开头大写；<br>**uppercase**：全部字母大写；<br>**lowercase**：全部字母小写|
|```text-indent```|规定文本块中首行字母的缩进|/|
<br>

**表格属性**
| 属性 | 描述 |
|-------|-------|
|``` border``` | 设置表格边框|
|```border-collapse```|设置表格边框是否被折叠成一个单一的边框或隔开|
|```width/height```|设置表格宽度/高度|
|```text-align```|设置表格中文本对齐属性|
|```color/background-color```|设置颜色/背景颜色|
<br>

* **
* ## 浮动

```float```属性定义元素在哪个方向浮动，任何元素都可以浮动

浮动只有左右浮动，没有上下浮动
浮动后的元素脱离了文档流，相当于ps里图层格外上加了一个图层，所以会出现折叠现象

当所有元素浮动的时候，会变成水平摆放，向左或向右，当容器不足时会在下一行摆放
* **
* ## 清除浮动
浮动的元素由于脱离了文档流，会导致其父元素高度塌陷，如果不想发生这种情况，就需要清除浮动带来的副作用

一般会用到四种方法

1. 父元素设置高度
给父元素设置```height```属性，将父元素撑开即可
2. 将受影响的元素增加```clear```属性
3. 如果父级塌陷，并且同级元素也受到了影响，可以在父级元素的样式里增加```overflow:hidden```，并在子级的样式里加```clear```属性
4. 通过伪元素的方法解决
在父标签添加伪类```after```，设置空的内容，并且使用```clear:both```注意父布局不设置高度
* **
* ## 定位

```position```属性指定了元素的定位类型
|值|描述|
|--|--|
|```relative```|相对定位|
|```absolute```|绝对定位|
|```fixed```|固定定位|
<br>

在设置定位之后可以使用```left、top、right、bottom```进行调整位置
**相对定位**
对象仍然处于常规的文档流中，但可以通过上面四个属性调整位置

**绝对定位**
对象脱离了文档流，此时偏移属性参照的是距离自身最近的定位祖先元素，如果没有定位的祖先元素，将追溯到```body```元素，每个绝对定位都像新开了一个图层，会出现覆盖情况，可以用```z-index```来调整

**固定定位**
与绝对定位相似，但偏移定位是以窗口为参考，用户滚动窗口时位置不变，具体应用就像广告栏和那种糊脸的广告

用好定位可以使界面更加美观，同时使模块发挥作用
* **
* ## 动画
动画可以使元素从一种样式逐渐变化为另一种样式

可以使用 **@keyframes** 来创建动画
```
@keyframes name{
    from|0%{
        css样式
    }
    percent{
        css样式
    }
    to|100%{
        css样式
    }
}
```
```name```：动画名称
```percent```：百分比值，可以添加多个

**animation执行动画**
```animation: name duration timing-function delay iteration-count direction;```
|值|描述|
|---|---|
|```name```|动画名称|
|```duration```|动画持续时间|
|```timing-function```|设置动画的速率|
|```delay```|设置动画的开始时间|
|```iteration-count```|动画循环次数，infinite为无限次循环|
|```direction```|播放方向|
|```animation-play-state```|控制动画的播放状态：running表示播放，paused表示暂停|
<br>

|timing-function的值|描述|
|----|----|
|```ease```|默认，逐渐变慢|
|```linear```|匀速|
|```ease-in```|加速|
|```ease-out```|减速|
|```ease-in-out```|先加速后减速|
<br>

|direction的值|描述|
|----|----|
|```normal```|默认，向前播放|
|```alternate```|偶数次向前播放，奇数次反向播放|
* **
* ## css嵌套

css嵌套使样式表更加容易阅读、模块化，同时也更容易维护，因为不需要重复选择器，文件同样可以被压缩

1.**子选择器**
可以使用css嵌套来创建一个父级的子选择器，这可以用来选择特定父元素的子元素，使用```&```来实现

有几个特定环境可以使得`` `&``` 嵌套选择器变得很必要或者有用：

-   在连接选择器时，如组合选择器或伪类
-   为了向后兼容。
-   作为一个辅助阅读的标志。当你看到 ```&``` 时，你就知道这里用到 CSS 嵌套了。
```
/* 不使用嵌套选择器 */
parent {
  /* 父样式 */
  child {
    /* 父级的子样式 */
  }
}

/* 使用嵌套选择器 */
parent {
  /* 父样式 */
  & child {
    /* 父级的子样式 */
  }
}

/* 浏览器均会把以上两个样式表解析为 */
parent {
  /* 父样式 */
}
parent child {
  /* 父级的子样式 */
}
```
2.**关系选择器**
css关系选择器也可在使用或不使用```&```嵌套选择器的情况下使用

```
h2 {
  color: tomato;
  + p {
    color: white;
    background-color: black;
  }
}
```
如果使用```&```嵌套选择器，只需在```+```前面加个```&```即可

3.**组合选择器**
与关系选择器不同，在使用组合选择器时，必须使用```&```嵌套选择器，这是因为浏览器会自动在不使用```&```嵌套选择器的选择器之间添加空格
```
.a {
  /* 带有 class="a" 元素的样式 */
  .b {
    /* 带有 class="b"，且为 class="a" 元素的子元素的样式 */
  }
  &.b {
    /* 带有 class="a b" 元素的样式 */
  }
}

/* 浏览器会将其分析为 */
.a {
  /* 带有 class="a" 元素的样式 */
}
.a .b {
  /* 带有 class="b"，且为 class="a" 元素的子元素的样式 */
}
.a.b {
  /* 带有 class="a b" 元素的样式 */
}
```

4.**后附嵌套选择器**
```&```嵌套选择器可以放到一个选择器的后方，这样可以反转上下文
```
.foo {
  /* .foo 的样式 */
  .bar & {
    /* .bar .foo 的样式 */
  }
}
```
<br>

如果一个嵌套 CSS 规则无效，那么所有其包含的样式都将被忽略。这不影响其父级及其后面的规则。

使用css嵌套可以将包含任何样式的at规则嵌入到另一个规则中。嵌套在at规则从距离它们最近的祖先规则中获得选择器定义

可以被嵌套的at规则有：

1. ```@media```
2. ```@support```
3. ```@layer```
4. ```@scope```
5. ```@container```

以```@media```为例，使用at规则嵌套的css为：
```
.foo {
  display: grid;
  @media (orientation: landscape) {
    grid-auto-flow: column;
  }
}
```
此时浏览器解析嵌套块是这样的：
```
.foo {
  display: grid;
  @media (orientation: landscape) {
    & {
      grid-auto-flow: column;
    }
  }
}
```
如果不使用at嵌套，那么它的等价表示是：
```
.foo {
  display: grid;
}

@media (orientation: landscape) {
  .foo {
    grid-auto-flow: column;
  }
}
```

at规则也可以嵌套其他at规则，如：
```
.foo {
  display: grid;
  @media (orientation: landscape) {
    grid-auto-flow: column;
    @media (min-width: 1024px) {
      max-inline-size: 1024px;
    }
  }
}
```
如果不使用嵌套的方法，它的等价表示是这样：
```
.foo {
  display: grid;
}
@media (orientation: landscape) {
  .foo {
    grid-auto-flow: column;
  }
}
@media (orientation: landscape) and (min-width: 1024px) {
  .foo {
    max-inline-size: 1024px;
  }
}
```
<br>

**嵌套的优先级**
```&```嵌套选择器的优先级由它所关联的选择器列表中优先级最高的选择器决定
```
<b class="foo">
  <c>蓝色文字</c>
</b>
```
```
#a, b {
  & c {
    color: blue;
  }
}

.foo c {
  color: red;
}
```
在这个示例中，ID 选择器（```#a```）的优先级是 ```1-0-0```，而类型选择器（```b```）的优先级是 ```0-0-1```。```&``` 嵌套选择器有 ```1-0-0``` 的优先级，尽管 ID 选择器 ```#a``` 从未使用。

类选择器 ```.foo``` 的优先级是 ```0-1-0```。经过计算得出，```& c``` 的总优先级是 ```1-0-1```，而 ```.foo c``` 的优先级是 ```0-1-1```，意味着 ```color: blue;``` 是最后赢家

在使用嵌套选择器的时候要注意优先级问题
*  **
* ## At规则
由于上文提到了at规则，于是在这里再做一下笔记

at规则是一个css语句，用来指示css如何运行，以```@```开头后跟一个标识符，并包括直到下一个分号的所有内容，或下一个 CSS 块，以先到者为准

下面是一些不同的at规则：
| 名称 |描述 |
|--|--|
|```@charset``` | 定义样式表使用的字符集|
| ```@import``` |告诉 CSS 引擎引入一个外部样式表 |
| ```@namespace``` | 告诉 CSS 引擎必须考虑 XML 命名空间 |
<br>

嵌套 at 规则，是嵌套语句的子集，不仅可以作为样式表里的一个语句，也可以用在条件规则组里：
| 名称 |描述  |
|--|--|
| ```@media``` |如果满足媒介查询的条件则条件规则组里的规则生效  |
|```@supports```  | 如果满足给定条件则条件规则组里的规则生效 |
|```@document```  |如果文档样式表满足给定条件则条件规则组里的规则生效  |
|``` @page``` | 描述打印文档时布局的变化 |
| ```@font-face``` | 描述将下载的外部的字体 |
| ```@keyframes``` | 描述 CSS 动画的中间步骤 |
| ```@layer```| 声明一个级联层，并在有多个级联层时定义优先顺序。|
<br>

**条件规则组**
每条at规则都有不同的语法，但一些at规则可以被归为一个特殊的分类：条件规则组。它们都使用相同的语法，它们都表达：它们所指的条件 (类型不同) 总等效于 **true** 或者 **false**，如果为 **true** 那么它们之中的语句生效。如```@media```、```@supports```、```@document```
* **
* ## 媒体查询

媒体查询可以使页面在不同终端下显示不同效果，会根据设备的大小自动识别加载不同的样式

**设置```meta```标签**
在```<head>```里加入这个```meta```标签能将使用设备的宽度作为初始宽度并禁止初始缩放
```
<meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1,user-scalable=no">
```
1. ```width=device-width```宽度等于当前设备的宽度
2. ```initial-scale=1.0```初始的缩放比例（默认1.0）
3. ```maximum-scale=1```允许用户缩放到的最大比例（默认1.0）
4. ```user-scalable=no```用户是否可以手动缩放 (默认是no）

```
@media screen and(max-width:768px)
/*设备小于768px加载样式 */
    body{}
}
@media screen and(max-width: 992px)and(min-width:768px){
/*设备小于768px但小于992px加载样式 */
    body{}
}
@media screen and(min-width:992px){
/*设备大于992px加载样式*/
    body{}
}
```
* ## flex布局
Flexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。

之所以称flexbox是一种一维的布局，是因为它不像grid布局一样可以同时处理行和列，它一次只能处理一行或者一列上的元素布局。

flexbox有两根轴线：**主轴**和**交叉轴**，主轴由```flex-direction```定义，可以取以下四个值：

1. ```row```（默认）
2. ```row-reverse```
3. ```column```
4. ```column-reverse```

有```-reverse```的相比没有的起始线和终止线相反![输入图片说明](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox/basics5.svg)

选择```row```或```row-reverse```主轴按行的方向延伸，反之主轴将上下延伸

交叉轴垂直于主轴

flex容器有多种属性：
|属性  |值  |描述|
|--|--|----|
|```flex-direction```|**row（默认）<br> row-reverse column<br> column-reverse**  | 改变flex元素的排列方向    |
|```flex-wrap```| **wrap <br>nowrap（默认）** | 项目太大无法显示在一行中时换行显示    |
|```align-items```|**stretch**(默认，元素拉伸到最高元素的高度)<br> **flex-start**(顶部对齐) <br>**flex-end**(底部对齐) <br>**center**(居中对齐)|使元素在交叉轴方向对齐|
|```justify-content```|**flex-start**(默认，元素从起始线排列)<br> **flex-end**(从终止线开始排列) <br>**center**(在中间排列)<br> **space-around**(元素之间间隔相等)<br> **space-between**(元素的左右空间相等)|使元素在主轴方向上对齐|
|```align-content```|**flex-start**(与交叉轴的起点对齐)<br>**flex-end**(与交叉轴的终点对齐) **center**(与交叉轴的中点对齐) <br> **space-between**(与交叉轴两端对齐，轴线之间的间隔平均分布) <br>**space-around**(每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍) <br>**stretch**(默认值，轴线占满整个交叉轴)|定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用|
<br>

```flex-direction```和```flex-wrap```这两种属性可以合并写为```flex-flow: 值1 值2```,第一个指定的值为 ```flex-direction``` ，第二个指定的值为 ```flex-wrap```

flex元素也有多种属性：

|属性|描述  |
|--|--|
|```flex-grow```  | 定义了在有可用空间时的放大比例 |
| ```flex-shrink``` | 定义了在空间不足时的缩小比例 |
|```lex-basis```  | 指定了项目在分配空间前的初始大小 |
<br>

这几个flex属性的作用其实就是改变了flex容器的可用空间的行为（在把flex项目用到多行的时候，应该把每一行都看作一个新的flex容器），这三个属性可以合并成```flex: 值1 值2 值3```，三个值分别对应```flex-grow```，```flex-shrink```，```flex-basis```

大多数情况下用预定义的简写形式
| 简写 | 相当于 |
|--|--|
|```flex: auto```  | ```flex: 1 1 auto ```|
|```flex: initial```  | ```flex: 0 1 auto ```|
|```flex: none```  | ```flex: 0 0 auto``` |
| ```flex: 1``` | ```flex: 1 1 0``` |
| ```flex: 2``` | ```flex: 2 1 0``` |
|```flex: num```|```flex: num 1 0```


* **
* ## grid布局

grid布局即网格布局，引入了二维网格布局系统

网格是一组相交的水平线和垂直线，它定义了网格的行和列，可以把网格元素放在这些行列相关的位置上

网格布局的特点有：

1. **固定的位置和弹性的轨道大小**：既可以使用固定的轨道尺寸创建网格，也可以使用百分比或者```fr```来创建有弹性尺寸的网格
2. **网格项摆放**：可以使用行号、行名或者标定一个网格区域来精确定位元素，同时还使用一种算法来控制未给出明确网格位置的元素
3. **创建额外的轨道来包含内容**：可以通过网格布局定义显式网格。网格布局规范非常灵活，可以在需要时添加额外的行和列。包括添加“一个容器能容纳的尽可能多的列”等特性
4. **对齐控制**：网格包含对齐特性，因此我们可以控制项目放入网格区域后的对齐方式，以及整个网格的对齐方式
5. **控制重叠内容**：多个项目可以放置在网格单元格中，或者区域可以部分地彼此重叠。然后可以使用 ```z-index``` 属性来控制重叠区域显示的优先级

通过在元素上声明```display: 	grid```来创建一个网格容器，里面的所有直系子元素都将成为网格项目

使用 ```grid-template-rows```和 ```grid-template-columns```属性定义网格上的行和列。这些属性定义了网格轨道。_网格轨道_（grid track）是网格上任意两条相邻线之间的空间。

轨道可以使用任何长度单位进行定义，也可以使用一个新单位```fr```来定义轨道大小，也可以混合使用单位如```grid-template-columns: 500px 1fr 2fr;```就是在可用空间扣除了500px宽度后再一分为三按比例分配

包含多个轨道的大型网格可使用 ```repeat()``` 标记来重复部分或整个轨道列表，如```grid-template-columns: 1fr 1fr 1fr;```就可以写成```grid-template-columns: repeat(3,1fr);```。同时```repeat()```也可以重复轨道列表中的一部分。如果是```repeat(5,1fr,2fr)```就意味着网格有十个轨道，为1个```1fr```后面跟着一个```5fr```，这样重复五次

如果希望行或列的大小永远不会小于一个值时，可以使用```minmax()```函数，如 ``` grid-auto-rows: minmax(100px, auto);```就意味着行高度最小为100px，最大为auto，使用 auto 表示大小将取决于内容的大小，并将拉伸以在该行中为单元格中最高的项目留出空间。

在定义网格时，定义的是网格轨道而非网格线，一个三行两列的网格中有四条纵向的网格线，网格线的编号顺序取决于文章的书写格式，网格线也可以被命名

使用 ```grid-column-start```、```grid-column-end```、```grid-row-start``` 和 ```grid-row-end``` 属性可以将项目放到自己想要的位置，也可以跨轨道放置，注意目标是网格线而不是网格轨道。这个有简写，如：```grid-column```和```grid-row```，值为 ```值1/值2```，值1为起始网格线，值2为终止网格线，也可以更进一步，合并为```grid-area```属性，同样用```/```分开，值的顺序为```grid-row-start```/```grid-column-start```/```grid-row-end```/```grid-column-end```

项目可以按行或者列跨越一个或多个单元格，形成了一个*网格区域*，网格区域必须是矩形的

网格单元格之间的横向间距或纵向间距可以使用```column-gap```和```row-gap```属性（简写为```gap```）

网格间距使用的任何空间都会在分配给灵活长度的 ```fr``` 轨道之前计算在内，而且网格间距的大小与常规网格轨道相同，但不能在间距中放置任何东西。就基于行的定位而言，网格间距就像一条粗线。

网格也可以嵌套，将一个网格项作为一个网格容器，如果不使用子网格的嵌套，那么嵌套网格和父网格没有任何关系，不会继承父网格的属性

*子网格*(subgrid)能让在创建嵌套网格的同时使用父网格的轨道定义，如将 ```grid-template-columns: repeat(3,1fr)```的轨道定义更改为 ```grid-template-columns: subgrid```。嵌套网格就会沿用父网格轨道来布局项目。

网格项可以占据同一单元格，可以使用```z-index```属性改变堆叠顺序（这里好像和绝对定位挺像的），就是当一个单元格被两个网格区域覆盖时就可以改变```z-index```的值决定谁在上面

在抉择布局方式时，应该思考是**只需要按行或者列布局**还是要**同时按行和列布局**，以此决定使用弹性盒子布局还是网格布局

css的网格布局是一种很好用的工具，应该大胆尝试与其他布局方法混用，获得想要的页面效果
* **
 * # JavaScript
 *  ## 简介
 
JavaScript是一种轻量级的脚本语言，所谓脚本语言，就是指它不具备开发操作系统的能力，只用来编写其他大型应用程序的脚本

JavaScript是一种嵌入式语言，它本身提供的核心语法不算很多

*  **
* ## JavaScript的语句和标识符
JavaScript程序单位是行，一般情况下一行就是一个语句，语句以分号结尾，一个分号表示一个语句结束

标识符指的是用来识别各种值的合法名称，最常见的就是各种变量名称，注意不能以数字开头
* **
* ## JavaScript引入方式
和css类似，JavaScript也有三种常用引入方式：

1. 嵌入到html文件中
用```<script></script>```标签包含js代码
2. 引入本地js文件
语法如```<script src="./js/1.js"></script>```在```src```里写入js文件的地址即可
3. 引入网络来源文件
即在```<script src=""></script>```的```src```里填入网络来源的js文件地址


* **
* ## 常用运算符
**typeof运算符**
JavaScript有三种方法可以确定一个值是什么类型，最先接触到的是```typeof```

1. 数值返回number
2. 字符串返回string
3. 布尔值返回boolean
4. 对象返回object
5. 没有数值返回undefined
<br>

**算数运算符**
| 运算符 | 描述 |
|--|--|
| ```+``` | 加 |
|``` -``` | 减 |
|``` * ```| 乘 |
| ```/``` | 除 |
|``` % ```| 取余 |
| ```p++``` | 先运算再自增 |
|``` ++p ```| 先自增再运算 |
<br>

**赋值运算符**
| 运算符 | 描述 |
|--|--|
|``` = ```| 赋值运算符 |
|``` +=``` | x+=y等同于x=x+y |
| ```-= ```| x-=y等同于x=x-y |
| ```/= ```| x/=y等同于x=x/y|
|``` *=``` | x*=y等同于x=x*y |
| ```%=``` | x%=y等同于x=x%y |
<br>

**比较运算符**
| 运算符 | 描述 |
|--|--|
|```<``` | 小于 |
| ```>``` | 大于 |
|``` <=``` | 小于等于 |
| ```>=``` | 大于等于 |
|``` ==``` | 相等 |
| ```===``` | 严格相等 |
| ```!= ```| 不等于 |
| ```!==``` | 严格不等于 |
<br>

**布尔运算符**
| 运算符 | 描述 |
|--|--|
|``` ! ```| 取反 |
| ```&&``` | 且 |
| ```||``` | 或 |
 * **
 *  ##条件语句
 
 **if语句**
 if语句先判断一个表达式的布尔值，然后根据布尔值的真伪执行不同的语句，语法如下：
 ```if(flag){要执行的语句}```
 
 **if...else语句**
 if代码块后面可以跟一个else代码块，表示不满足条件时要执行的代码，语法如下：
  ```
  if(flag){
        要执行的语句
    }else{
        要执行的语句
    } 
```
如果在不同条件下要执行不同的代码，可以使用if...else if...else语句，else if可以任意多，语法如下：
```
  if(flag){
        要执行的语句
    }else if(flag2){
        要执行的语句
    }else{
        要执行的语句
    } 
```
<br>

**switch语句**
在有多种选择的情况下也可以考虑使用switch语句，注意的是每一个```case```最后都要有一个```break```，否则会继续执行下一个case代码块，语法如下：
```
   switch(变量){
       case 值1:
           代码块
           break;
       case 值2:
           代码块
           break;
       case 值3:
           代码块
           break;
       default:
           代码块
   }
```
* **
* ## 循环语句
循环语句就是重复执行某个操作

**for语句**
for语句就是循环命令，可以指定循环的起点、终点和终止条件，语法如下：
```
for(初始化表达式;条件;循环因子){
    要循环的语句
    }
```
其中初始化表达式只在循环开始时执行一次，条件每轮循环开始时都要执行一遍，只有布尔值为真时才执行此次循环，循环因子是每轮循环的最后一次操作，通常用来递增循环变量

** while语句**
while语句包含一个循环条件和代码块，只要条件为真就执行代码块，直到条件为假时或遇到```break```跳出循环，语法如下：
```
while(条件){要循环的语句}
```
需要注意的是在语句内应该有改变与条件有关变量的语句或```break```语句，防止出现死循环

所有for循环都可以写成while循环，反之亦然

循环语句可以嵌套，通过循环语句嵌套可以实现想要实现的效果

**break语句和continue语句**
```break```和```continue```都可以让代码不按原有的顺序进行

```break```语句用于跳出代码块或者循环，遇到```break```意味着循环的结束

```continue```语句意味着立刻终止本轮循环，返回循环体的头部，开始下一轮循环
 *   **
 * # 图解HTTP笔记
 * ## 第一章 了解Web及网络基础

Web使用一种名为HTTP(HyperText Transfer Protocol，超文本传输协议)的协议作为规范，完成从客户端到服务器端灯一系列运作流程，可以说，Web是建立在HTTP协议上通信的

CERN（欧洲核子研究组织）的蒂姆·伯纳斯-李博士提出了一种能让远隔两地的研究者们共享知识的设想

现在已经提出了三项WWW（World Wide Web，万维网）构建技术，分别是：
1. **HTML**（HyperText Markup Language，超文本标记语言），它的页面文本标记语言为SGML（Standard Generalized Markup Language，标准通用标记语言）
2. **HTTP**，作为文档传递协议
3. **URL**（Uniform Resource Locator，统一资源定位符）
<br>

CERN成功研发了世界上第一台Web服务器和Web浏览器

HTTP于1990年问世，但没有作为正式的标准被建立，被称为HTTP/0.9。HTTP正式作为标准被公布是在1996年五月，被命名为HTTP/1.0，该协议标准至今仍被广泛用于服务器端。1997年一月公布的HTTP/1.1是目前主流的HTTP协议版本，当初的标准是RFC0，之后的修订版RFC2616就是当前的最新版。

当年HTTP协议主要是为了解决文本传输的难题，但现在已经超出了Web框架的局限

通常使用的网络是在**TCP/IP**协议族的基础上运作的，HTTP是它内部的一个子集

计算机与网络设备要互相通信就必须基于相同的方法，我们把这个规则称为**协议**，而TCP/IP就是互联网相关各类协议族的总称（也有说法是TCP协议和IP协议，或者是IP协议通信过程中使用到的协议族的统称）

TCP/IP协议很重要的一点就是分层，其按层次分分为**应用层、传输层、网络层、数据链路层**，分层使各个层次内部的设计可以自由改动，简化设计。各层的作用如下：
|层|作用  |
|--|--|
| **应用层** |决定了向用户提供应用服务时通信的活动，HTTP协议也属于该层  |
| **传输层** | 对上层应用层提供处于网络连接中的两台计算机之间的数据储传输，有TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol， 用户数据报协议） |
| **网络层（网络互连层）** |处理网络上流动的数据包，规定通过怎样的路径（传输路线）到达对方计算机传送数据包  |
| **链路层** |处理连接网络的硬件部分，硬件上的范畴均在链路层的作用范围里  |
<br>

在利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信，发送端从应用层向下走，接收端从链路层向上走

发送端在层与层之间传输数据时，每经过一层必定会打上该层所属的首部信息，而接收端则在层与层传输时消去对应的首部
|XX层->XX层| 首部|
|--|--|
| **应用层->传输层** | TCP首部 |
| **传输层->网络层** | IP数据包（IP首部） |
|  **网络层->链路层** | 网络架构（以太网首部） |
这种把数据信息像快递一样层层包装起来的做法叫做封装

TCP/IP协议中与HTTP协议密不可分的有三个协议：

1. **IP协议**
IP（Internet Protocol）协议负责传输，属于网络层，几乎所有使用网络的系统都会用到这个协议。IP 协议的作用是把各种数据包传送给对方。要保证确实传送到对方那里要满足各种条件，最重要的是IP 地址和 MAC地址（Media Access Control Address）<br><br>IP 地址（可以更改）指明了节点被分配到的地址， MAC 地址（基本上不会更改）是指网卡所属的固定地址。<br><br>IP间的通信依赖MAC地址，因为通信通常是要经过多台计算机和网络设备中转，中转时就要利用下一个设备的MAc地址来搜索，这时会采用ARP协议（Address Resolution Protocol，是一种用以解析地址的协议， 根据通信方的 IP 地址就可以反查出对应的 MAC 地址）<br><br>在到达通信目标前，中转计算机和路由器只能获得很粗略的传输路线，这种机制成为路由（routing），无论哪台计算机、网络设备都无法全面掌握互联网的细节
2. **TCP协议**
TCP协议用于确保可靠性，属于传输层，提供可靠的字节流服务<br><br>字节流服务指的是为了方便传输将大块数据分割成以报文段为单位的数据包进行管理。TCP协议为了更容易传送大数据才将数据分割，而且能够确认数据最终是否送达到对方<br><br>为了准确送达，TCP协议采用了三次握手策略，在用TCP协议将数据包送出去后，TCP一定会向对方确认是否成功送达，握手过程中使用TCP的标志（flag）——**SYN**（synchronize）和**ACK**（acknowledgement）<br><br>首先，发送端会发送带SYN标志的数据包给对方，接收端收到后，回传一个带有SYN/ACK标志的数据包表示确认，此时发送端会回传一个带ACK标志的数据包，代表“握手”的结束。如果握手过程突然中断，TCP协议会再以相同的顺序发送数据包。<br><br>（除了上述三次握手， TCP 协议还有其他各种手段来保证通信的可靠性）
3. **DNS协议**
DNS（Domain Name System）协议负责域名解析，属于应用层，提供域名到IP地址间的解析服务<br><br>计算机可以被赋予IP地址、主机名、域名，用户通常使用主机名和域名来访问对方的计算机（因为IP地址是一组纯数字），但是计算机比起处理名称更擅长处理一长串数字，由此，DNS服务诞生了，它提供提供域名查找IP地址，或通过IP地址逆向搜索域名的服务<br><br>发送端想访问一个域名，DNS协议会查找到这个域名对应的IP地址，然后发送端会向这个IP地址发送访问请求

如果要把通信过程中各个协议的作用表述出来，大概就像这样：
发送端想访问一个域名
**DNS协议**会查找到这个域名对应的IP地址。
**HTTP协议**会生成针对目标Web服务器的HTTP请求报文。
**TCP协议**将请求报文分割成多段，按序号分层多个报文段然后将每个报文段可靠地传给对方。
**IP**协议搜索对方的地址，一边中转一边传输。
接收端的**TCP协议**按序号重组报文段。
接收端的**HTTP协议**处理对Web服务器请求的内容。
请求的处理内容同样利用TCP/IP通信协议进行回传

与 URI（统一资源标识符）相比，我们更熟悉 URL（Uniform Resource Locator，统一资源定位符）。URL正是使用 Web 浏览器等访问 Web 页面时需要输入的网页地址。

URI 是 Uniform Resource Identifier 的缩写
**Uniform：**规定统一的格式，方便处理多种不同类型的资源，不需要根据上下文环境来识别资源指定的访问方式，加入新的协议方案也更容易
**Resource：**资源的定义是“可标识的任何东西”。资源不仅可以是单一的， 也可以是多数的集合体
**Identifier：**表示可标识的对象。 也称为标识符

URI 就是由某个协议方案表示的资源的定位标识符，协议方案是指访问资源所使用的协议类型名称，比如采用HTTP协议时，协议方案就是http

URI 用字符串标识某一互联网资源，而 URL表示资源的地点（互联网上所处的位置） 。可见 URL是 URI 的子集

表示指定的URI，可以使用**绝对URI、绝对URL、相对URL**，相对URL指的是从浏览器中基本URI处指定的URL，如 /image/logo.gif

**绝对URI**组成如下：
|名称|描述  |
|--|--|
| **协议方案名** |使用http:或 https:等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）|
|**登录信息**  | （可选），指定用户名和密码作为从服务器端获取资源时必要的登录信息 |
| **服务器地址** | 使用绝对URI必须指定待访问的服务器地址。地址可以是类似hackr.jp这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名，还可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的IPv6地址名 |
| **服务器端口号** | （可选）指定服务器连接的网络端口号。若用户省略则自动使用默认端口号 |
| **带层次的文件路径** | 指定服务器上的文件路径来定位特指的资源 |
|**查询字符串**  | （可选）针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数 |
| **片段标识符组成** |（可选）使用片段标识符通常可标记出已获取资源中的子资源  |
<br>

有一些用来制定 HTTP 协议技术标准的文档,它们被称为RFC（Request for Comments, 征求修正意见书）,不遵照 RFC 标准实现就无法进行 HTTP 协议通信

* **
* ##第二章 简单的HTTP协议

应用HTTP协议时，一端担任客户端角色，一端担任服务器端角色，请求访问资源的是客户端，提供资源响应的是服务器端，角色有可能互换，但HTTP协议能明确区分哪个是客户端哪个是服务器端

HTTP协议规定请求从客户端发出，服务器端响应请求并返回

这个是从客户端发出的请求报文的内容：
```
GET/index.htm HTTP/1.1
Host:hackr.jp
```
开头的```GET```表示请求访问服务器的类型，称为方法
字符串```/index.htm```指明了请求访问的资源对象，也叫做请求URI
最后的HTTP/1.1是HTTP的版本号
请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的

收到请求的服务器会将请求内容的处理结果以响应的形式返回
```
HTTP/1.1 200 OK
Date: Tue, 10 Jul 2012 06:50:15 GMT Content-Length: 362
Content-Type: text/html
<html>
……
```
开头的```HTTP/1.1```表示服务器对应的HTTP版本
```200 OK```表示请求处理结果的状态码和原因短语。
下一行显示了创建响应的日期时间，是首部字段内的一个属性
空一行
后面是资源实体的主体

响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码） 、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成

HTTP是无状态协议，意味着它不保存状态，在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。这个是为了更快地处理大量事务，确保协议的可伸缩性

但随着发展，有些情况网站需要保存用户的状态，于是引入了Cookie技术，这样就可以管理状态了

由于URI的存在，使HTTP协议能定位互联网上的资源从而进行访问

当客户端请求访问资源而发送请求时，URI 需要将作为请求报文中的请求 URI 包含在内。如果不是访问特定资源而是对服务器本身发起请求，可以用一个 * 来代替请求 URI，如：
```
OPTIONS * HTTP/1.1
```
<br>

方法的作用在于可以指定请求的资源按期望产生某种行为，HTTP/1.1中可使用的方法（method）：
1. **GET：获取资源**
GET用来<u>请求访问已被URI识别的资源</u>。指定的资源经服务器端解析后返回响应内容
2. **POST：传输实体主体**
虽然GET方法也可以传输实体的主体，但一般不用GET方法而是使用POST方法，虽然相似，<u>但POST方法的主要目的斌不是回去响应的主体内容</u>
3. **PUT：传输文件**
PUT方法用来传输文件，要求<u>在请求的报文的主体中包含文件内容，然后保存到请求URI指定的位置</u>。但是HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，一般的Web网站不使用该方法。若配合 Web 应用程序的验证机制，或架构设计采用REST（REpresentational State Transfer，表征状态转移）标准的同类Web 网站，就可能会开放使用 PUT 方法。
4. **HEAD：获取报文首部**
该方法和GET方法一样，只是<u>不返回报文主体部分</u>，用来确认URI的有效性和资源更新的日期时间等
5. **DELETE：删除文件**
是和PUT相反的方法，按请求URI删除指定的资源。但它也和PUT一样没有验证机制，一般Web网站不使用
6. **OPTIONS：询问支持的方法**
用来查询针对请求URI指定的资源支持的方法
7. **TRACE：追踪路径**
该方法是让Web服务器将之前的请求通信环回给客户端的方法<br><br>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。<br><br>客户端用TRACE方法可以查询发出去的请求是怎么样被加工修改的，确认连接过程中发生的一系列操作<br><br>但是TRACE方法本来就不常用，还容易引发XST（Corss-Site Tracing，跨站追踪）攻击
8. **CONNECT：要求用隧道协议连接代理**
该方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security， 传输层安全）协议把通信内容加密后经网络隧道传输

向请求URI指定的资源发送请求报文时，采用称为方法的命令

除了以上方法，HTTP/1.0还有LINK（建立和资源之间的联系）和UNLINK（断开连接关系）方法，但已被HTTP/1.1废弃

在HTTP的初始版本中，每进行一次HTTP通信都要断开一次TCP连接，每次请求都会造成无谓的TCP连接建立和断开，增加通信量的开销

为了解决这个问题，HTTP/1.1和一部分的HTTP/1.0推出了**持久连接**的方法，只要任意一端没有明确提出断开连接就保持TCP连接状态。这种方法减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。在HTTP/1.1中，所有连接默认都是持久连接

持久连接使**管线化**成为可能，<u>不需要等待上一个请求得到响应就可以之间发送下一个请求</u>,速度更快

在上面的笔记中有提到Cookie技术的引入使Web可以进行状态的管理

**Cookie技术**通过在请求和响应报文中写入Cookie信息来控制客户端的状态。如果客户端的请求报文中没有Cookie的相关信息，服务器端发送的响应报文中会有一个叫Set-Cookie的首部字段信息通知客户端保存Cookie。客户端以后的请求中会自动在请求报文中加入Cookie值后发送。服务器端在发现客户端发来的Cookie后回去检查时哪个客户端发来的请求，对比服务器上的记录，得到之前的状态信息

 * **
 * ## 第三章 HTTP报文内的HTTP信息
 
用于HTTP协议交互的信息被称为HTTP报文，请求端的叫**请求报文**，响应端的叫**响应报文**。HTTP报文本身是由多行数据（CR+LF作换行符）数据构成的字符串文本

HTTP报文大致分为报文首部和报文主体，由空行划分，并不一定要有报文主体

请求报文和响应报文首部的结构：
|请求报文| 响应报文 |
|--|--|
|请求行  | 状态行 |
| 请求首部字段 | 响应首部字段 |
| 通用首部字段 | 通用首部字段 |
| 实体首部字段 | 实体首部字段 |
| 其他 | 其他 |
<br>

**请求行**
包含请求的方法、请求URI和HTTP版本
**状态行**
包含表明响应结果的状态码，原因短语和HTTP版本
**首部字段**
一般有四种首部，分别是**通用首部、请求首部、响应首部和实体首部**（可能还有Cookie等）

通过在传输时编码，能有效处理大量访问请求。编码操作需要计算机完成，会消耗更多CPU资源

**报文**是HTTP通信的基本单位，由8位组字节流组成，通过HTTP通信传输
**实体**是作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成

HTTP 报文的主体用于传输请求或响应的实体主体，通常报文主体等于实体主体，但当传输中进行编码操作时实体主体内容发生变化，于是产生了差异

HTTP协议中有一种被称为**内容编码**的功能，内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩，内容编码后的实体由客户端接收并负责解码

常用的内容编码有以下几种：
1. gzip（GNU zip）
2. compress（UNIX 系统的标准压缩）
3. deflate（zlib） 
4. identity（不进行编码）

如果请求段编码实体资源尚未全部传输完成，浏览器无法显示请求页面，所以在传输大容量数据时，通过把数据分割成多块**分割物（chunk）**，能够让浏览器逐步显示页面，这种功能称为**分块传输编码**

每一块分割块都会用十六进制来标记大小，实体主体的最后一块会使用“0（CR+LF）”来标记，使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到解码前的实体主体

HTTP 协议中采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用

多部分对象集合包含的对象如下：
1. **multipart/form-data**
在Web表单文件上传时使用
2. **multipart/byteranges**
状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用

在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上Content-type

boundary字符串用来划分多部分对象集合指明的各类实体。在其指定的各个实体的起始行前插入“--”标记，在多部分对象集合对应的字符串的最后插入“--”标记作为结束

如果下载时网络中断，那么就不得不再次从头下载，这个问题想要得到解决需要指定下载的实体范围。指定范围发送的请求叫做**范围请求**

执行范围请求时，会用到首部字段Range来指定资源的byte范围

```Range：bytes=5000-10000```就是指定了5000~10000字节，也可以有```Range：bytes=5000-10000，12000-15000```的双重范围

针对范围请求，响应会返回状态码为206 Partial Content的响应报文。如果是多重范围，那么响应会在首部字段ContentType标明multipart/byteranges后返回响应报文

（如果服务器端没办法响应范围请求，那么就会返回状态码200 OK和完整的实体内容）

**内容协商**机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源，包含在请求报文中的某 些首部字段会作为判断是否是最合适资源的基准，如：**Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language**

内容协商技术有三种类型：
|类型| 描述 |
|--|--|
| **服务器驱动协商** | 由服务器端进行内容协商，以请求的首部字段进行参考，但对用户来说不一定是最合适的 |
| **客户端驱动协商** | 由客户端进行内容协商，就类似于手动选择浏览器语言。存在需要第二次请求而获得最好表现形式的缺点。第二次请求只有当缓存被使用时才是有效率的 |
| **透明协商** | 服务器驱动和客户端驱动的结合体，两端各自进行内容协商。结合了服务器和客户端的协商能力，能够更好地满足不同用户的需求。通过缓存利用代理驱动协商的信息，减少了服务器的负担，提高了响应速度。提供最适合用户的资源，提升用户体验‌ |
* **
* ## 第四章 返回结果的HTTP状态码
HTTP状态码负责表示客户端HTTP请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。用户根据状态码，可以知道服务器端是正常处理了请求，还是出现了错误

|  | 类别 | 原因短语 | 
|--|--|--|
| **1XX** | Informational（信息性） | 接收的请求正在处理 |
| **2XX** | Success（成功状态码） | 请求正常处理完毕 |
| **3XX** | Redirection（重定向状态码） | 需要进行附加操作以完成请求 |
| **4XX** | Client Error（客户端错误状态码） | 服务器无法处理请求 |
| **5XX** | Server Error（服务器错误状态码） | 服务器处理请求出错 |

经常使用的状态码共有14种：

* **2XX类**
   1. **200 OK**：表示客户端发来的请求在服务器端被正常处理了
   2. **204 No Content**：服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分
   3. **206 Partial Content**：表示客户端进行了范围请求，服务器成功执行了这部分的GET请求，响应报文中包含由 Content-Range 指定范围的实体内容
   
* **3XX类**
    4. **301 Moved Permanently**：永久性重定向，表示请求的资源已经被分配了新的URI，以后应该使用资源现在所指的URI
    5. **302 Found**：临时性重定向，该状态码表示请求的资源已经被分配了新的URI，希望用户（本次）能使用新的URi访问。虽然与301 Moved Permanently类似，但该状态码代表的资源不是永久移动，而是临时性的，未来URI可能还会改变
    6. **303 See Other**：表示由于请求对应的资源 存在另一个URI，应该使用GET方法定向获取请求的资源。与302 Found相似，但明确要求客户端用GET方法获取资源  
 
 
    当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。<br><br>（301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做）（草）
    7. **304 Not Modified**：表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。虽然该状态码为3XX，但和重定向没有关系
    8. **307 Temporary Redirect**：临时重定向，与302 Found有相同含义，尽管302标准禁止POST变换成GET，但大家都不遵守。307不会从POST变GET
* **4XX类**
    9. **400 Bad Request**：表示请求报文中存在语法错误，浏览器会像200 OK一样对该状态码
    10. **401 Unauthorized**：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息，若之前已经进行过一次请求，则表示用户认证失败<br><br>返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用来质询（challenge）用户信息，浏览器第一次接收到401响应的时候会弹出认证用对话窗口 
    11. **403 Forbidden**对请求资源的访问被服务器拒绝，服务器端没有必要给出拒绝的理由，但可以在实体的主体部分对原因进行描述让用户明白
    12. **404 Not Found**：服务器上无法找到请求的资源，也可以在服务器端拒绝请求不想说明理由时使用
 * **5XX类**
    13. **500 Internal Server Error**：服务器端在执行请求时发生了错误
    14. **503 Service Unavailable**：服务器正在进行停机维护或暂时处于超负载状态，无法处理请求。如果事先得知解除以上状况需要的时间，最好写入RetryAfter首部字段再返回给客户端
 <br>
 
（不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种情况也经常遇到)
 * **
* ## 第五章 与HTTP协作的Web服务器
一台Web服务器可以搭建多个独立域名的Web网站，也可以作为通信路上的中转服务器提示传输效率

HTTP/1.1规范允许一台HTTP服务器搭建多个Web站点，即使物理层面只有一台服务器，但只要使用了**虚拟主机（又称虚拟服务器）**的功能就可以假想已具有多台服务器

当客户端使用HTTP协议访问服务器时，经常会采用主机名和域名，这些域名通过DNS服务映射到IP地址之后访问目标网站，所以当一台服务器内托管了多个域名，收到请求时就要搞清楚究竟要访问哪个域名（这是因为它们的IP地址会相同）。这时就必须在发送HTTP请求时在Host首部内完整指定主机名或域名的URI

在HTTP通信时，除了客户端和服务器还有一些用于通信数据转发的应用程序，如**代理、网关、隧道**。这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端

1. **代理：**
代理是一种有转发功能的应用程序，扮演了位于服务器和客户端“中间人”的角色，接收客户端的请求转发给服务器，也接收服务器的响应转发给客户端
<br>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI。持有资源实体的服务器称为源服务器，从源服务器返回的响应经过代理服务器后再传给客户端
<br>每次通过代理服务器转发时会追加写入**Via**首部信息
<br>使用代理服务器可以利用缓存技术减少网络宽带的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的
<br>代理有多种使用方法，按两种基准分：**一种是是否使用缓存，另一种是是否会修改报文**<br>
缓存代理：代理转发响应时会预先将资源的副本（缓存）保存在代理服务器上。当代理再次收到对相同资源的请求时，就可以不从服务器获取资源，而是将之前缓存的资源作为响应返回
<br>透明代理：转发或响应时不对报文做任何加工的代理。反之对报文内容进行加工的称为非透明代理
2. **网关：**
网格是转发其他服务器通信数据的服务器，接收从客户端发来的请求时就像自己拥有资源的服务器用于对请求进行处理
<br>利用网关可以由HTTP请求转化为其他协议通信。网关的工作机制和代理相似，但网关能使通信线路上的服务器提供非HTTP协议服务
<br>利用网关能提高通信的安全性，因为可以在客户端和网关之间的通信线路上加密确保连接安全
3. **隧道：**
隧道是在相隔很远的客户端与服务器进行中转，并保持双方通信连接的应用程序
<br>隧道可以按要求建立起一条与其他服务器的通信道路，使用SSL等加密手段进行通信，目的是确保客户端能和服务器安全通信
<br>隧道本身不会去解析HTTP请求。隧道会在通信双方断开连接时结束

**缓存**指的是代理服务器或客户端本地磁盘内保存的资源副本，利用缓存可以减少对源服务器的访问，节省通信流量和通信时间

缓存服务器是代理服务器的一种，并归类在缓存代理类型中。换句话说，当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。这样源服务器就不用多次处理相同的请求了

缓存是有有效期限的，当源服务器的资源更新时，如果缓存没有更新，那么响应的内容就是之前的旧资源。即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源有效性，如果判断缓存失效，就会再次从服务器上获取资源

缓存不仅可以存在缓存服务器内，也可以存在客户端浏览器里面。浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。如果失效就会和缓存服务器一样向源服务器请求新资源

* **
* ## 第六章 HTTP首部
HTTP协议的请求和响应报文中一定包含HTTP首部，即使平时使用Web的时候感受不到它们

首部内容为客户端和服务器分别处理请求和响应提供所需要的信息

HTTP首部字段是构成HTTP报文的要素之一，无论是请求还是响应都会使用首部字段，它起到传递额外重要信息的作用。使用首部字段可以给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容

HTTP首部字段由**首部字段名**和**字段值**组成，中间由```:```分隔，字段值对应的单个HTTP首部字段可以有多个值，如```Keep-Alive：timeout=15，max=100```

如果首部字段重复，根据浏览器内部处理逻辑的不同可能会有不同的结果，有的处理第一次，有的处理最后一次

HTTP首部字段根据实际用途被分为四种类型：
|类型| 描述 |
|--|--|
| **通用首部字段** | 请求报文和响应报文都会使用的首部 |
| **请求首部字段** |从客户端向服务器端发送请求报文时使用的首部，补充了请求附加内容、客户端信息、响应内容相关优先级等 |
|**响应首部字段** | 从服务器端向客户端返回响应报文时使用的首部，补充了响应的附加内容，也会要求客户端附加额外的内容信息 |
|**实体首部字段**  | 针对请求报文和响应报文的实体部分使用的首部，补充了资源内容更新时间等与实体有关的信息|

<br>

| 通用首部字段 | 描述 |
|--|--|
| **Cache-Control** | 控制缓存的行为 |
| **Connection** | 逐跳首部、 连接的管理 |
| **Date** | 创建报文的日期时间 |
| **Pragma** | 报文指令 |
| **Trailer** | 报文末端的首部一览 |
| **Transfer-Encoding** | 指定报文主体的传输编码方式 |
| **Upgrade** | 升级为其他协议 |
| **Via** | 代理服务器的相关信息 |
| **Warning** | 错误通知 |
<br>

| 请求首部字段 | 描述 |
|--|--|
| **Accept** | 用户代理可处理的媒体类型 |
| **Accept-Charset** | 优先的字符集 |
| **Accept-Encoding** |优先的内容编码 |
| **Accept-Language** | 优先的语言（自然语言） |
| **Authorization** | Web认证信息 |
| **Expect** | 期待服务器的特定行为 |
| **From** | 用户的电子邮箱地址 |
| **Host** | 请求资源所在服务器 |
| **If-Match** |比较实体标记（ETag）|
| **If-Modified-Since** | 比较资源的更新时间 |
| **If-None-Match** | 比较实体标记（与 If-Match 相反） |
| **If-Range** | 资源未更新时发送实体 Byte 的范围请求 |
| **If-Unmodified-Since** | 比较资源的更新时间（与If-Modified-Since相反） |
| **Max-Forwards** | 最大传输逐跳数 |
| **Proxy-Authorization** | 代理服务器要求客户端的认证信息 |
| **Range** | 实体的字节范围请求 |
| **Referer** | 对请求中 URI 的原始获取方|
| **TE** | 传输编码的优先级|
| **User-Agent** | HTTP 客户端程序的信息|
<br>

|响应首部字段名|描述|
|--|--|
|**Accept-Ranges**|是否接受字节范围请求|
|**Age**|推算资源创建经过时间|
|**ETag**|资源的匹配信息|
|**Location**|令客户端重定向至指定URI|
|**Proxy-Authenticate**|代理服务器对客户端的认证信息|
|**Retry-After**|对再次发起请求的时机要求|
|**ServerHTTP**|服务器的安装信息|
|**Vary**|代理服务器缓存的管理信息|
|**WWW-Authenticate**|服务器对客户端的认证信息|
<br>

|实体首部字段名|说明|
|--|--|
|**Allow**|资源可支持的HTTP方法|
|**Content-Encoding**|实体主体适用的编码方式|
|**Content-Language**|实体主体的自然语言|
|**Content-Length**|实体主体的大小（单位： 字节）|
|**Content-Location**|替代对应资源的URI|
|**Content-MD5**|实体主体的报文摘要|
|**Content-Range**|实体主体的位置范围|
|**Content-Type**|实体主体的媒体类型|
|**Expires**|实体主体过期的日期时间|
|**Last-Modified**|资源的最后修改日期时间|
<br>

还有一些非HTTP/1.1首部字段，如Cookie、Set-Cookie、Content-Disposition等等，这些非正式的首部字段统一归纳在RFC4229 HTTP Header Field Registrations中

HTTP首部字段将定义成缓存代理和非缓存代理的行为，分成两种类型：
**端到端首部：** 分在此类别的首部会转发给请求/响应对应的最终目标，且必须保存在缓存生成的响应中，另外规定它必须被转发
**逐跳首部：** 分在此类别的首部只对单词转发有效，会因提供缓存或代理而不再转发，在HTTP/1.1和之后的版本中，要使用这类首部需要提供Connection首部字段

HTTP/1.1中的逐条首部有**Connection、Keep-Alive、Proxy-Authenticate、Proxy-Authorization、Trailer、TE、Transfer-Encoding、Upgrade**。除了这些，其他都是端到端首部
* **
* ### 通用首部字段
 **Cache-Control：**
通过指定首部字段**Cache-Control**的指令，就能操作缓存的工作机制，指令的参数是可选的，多个指令通过","分隔

|缓存请求指令| 参数 |说明|
|--|--|--|--|
|**no-cache** |无 |强制向源服务器再次验证|
|**no-store** |无| 不缓存请求或响应的任何内容|
|**max-age = [ 秒]**| 必需| 响应的最大Age值|
|**max-stale( = [ 秒])**| 可省略| 接收已过期的响应|
|**min-fresh = [ 秒]**|必需|期望在指定时间内的响应仍有效|
|**no-transform**|无|代理不可更改媒体类型|
|**only-if-cached**|无|从缓存获取资源|
|**cache-extension**|-|新指令标记（token）|
<br>

|缓存响应指令|参数|说明|
|--|--|--|
|**public**|无|可向任意方提供响应的缓存|
|**private**|可省略|仅向特定用户返回响应|
|**no-cache**|可省略|缓存前必须先确认其有效性|
|**no-store**|无|不缓存请求或响应的任何内容|
|**no-transform**|无|代理不可更改媒体类型|
|**must-revalidate**|无|可缓存但必须再向源服务器进行确认|
|**proxy-revalidate**|无|要求中间缓存服务器对缓存的响应有效性再进行确认|
|**max-age = [ 秒]**|必需|响应的最大Age值|
|**s-maxage = [ 秒]**|必需|公共缓存服务器响应的最大Age值|
|**cache-extension**|-|新指令标记（token)|
<br>

当指定使用```public```指令时，表明其他用户也可以利用缓存。与其相反，```private```指令指定后响应只以特定的用户作为对象，对于其他用户发送过来的请求，代理服务器则不会返回缓存

使用```no-cache```指令的目的是为了防止从缓存中返回过期的资源。如果请求中包含了```no-cache```，那么就表示客户端不接受缓存过的响应，中间的缓存服务器必须把请求转发给源服务器

如果是服务器的响应中包含```no-cache```，那么缓存服务器不能对该资源进行缓存

由服务器返回的响应中， 若报文首部字段 ```Cache-Control ```中对```no-cache```字段名具体指定参数值， 那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。**只能在响应指令中指定该参数**

当使用```no-store```指令时，暗示请求或响应中包含机密信息，所以该指令规定缓存不能在本地存储请求或响应的任一部分（```no-store```才是真正的不缓存，```no-cache```代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源）

**s-maxage指令：** 其功能和```max-age```相同，它们的不同点是```s-maxage```指令只适用于供多位用户使用的公共缓存服务器（指代理，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用

使用```s-maxage```指令后，则直接忽略对Expires首部字段及```max-age```指令的处理

**max-age指令：** 当客户端发送的请求中包含```max-age```指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。如果其值为0，就要把请求转发给源服务器

服务器端的响应包含```max-age```指令时，缓存服务器将不对资源的有效性再作确认，其值代表资源保存为缓存的最长时间

HTTP/1.1版本的缓存服务器会优先处理```max-age```而忽略掉Expires首部字段，HTTP/1.0却刚好相反

**min-fresh指令：** 要求缓存服务器返回至少还未过指定时间的缓存资源

**max-stale指令：** 可以指示缓存资源即使过期也照样接收，未指定参数的话，那么无论经过多久，客户端都会接收响应。反之只要仍处于 max-stale指定的时间内，仍旧会被客户端接收

**only-if-cached指令：** 使用该指令代表客户端仅在缓存服务器缓存目标资源的情况下才要求其返回。若发生请求缓存服务器的本地缓存无响应，则返回状态码504 Gateway Timeout

**must-revalidate指令：** 使用该指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。如果代理无法联通源服务器获取有效资源的话就必须返回504状态码。

使用该指令会忽略请求中的```max-stale```指令

**proxy-revalidate指令：** 该指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性

**no-transform指令：** 该指令规定无论在请求还是响应中，缓存都不能更改实体主体的媒体类型

通过cache-extension标记（token），可以扩展Cache-Control首部字段内的指令
```Cache-Control: private, community="UCI"```
Cache-Control 首部字段本身没有 community 这个指令。借助extension tokens 实现了该指令的添加。如果缓存服务器不能理解```community```这个新指令就会直接忽略

**Connection**首部具有两个作用：

1. 控制不再转发给代理的首部字段
```Connection: 不再转发的首部字段名```
2. 管理持久连接
HTTP/1.1版本的默认连接都是持久连接，当服务器端明确想断开连接时，会将其值改为Close

在之前的HTTP版本中默认是非持久连接，如果想要在旧版HTTP协议上维持持续连接，需要将其值改为Keep-Alive

**Date**表面创建HTTP报文的日期和时间
HTTP/1.1用的格式为```Date: Tue, 03 Jul 2012 04:40:59 GMT```

**Pragma**是HTTP/1.1之前版本的历史遗留字段，仅作为HTTP/1.0的向后兼容而定义

规范定义的形式唯一，如下所示：
```Pragma: no-cache```
虽然该首部字段属于通用首部字段，但只用在客户端发送的请求中，客户端会要求所有的中间服务器不返回缓存的资源

但是可能有点中间服务器版本不是HTTP/1.1，所以发送的请求会有下面两个首部字段：
```
Cache-Control: no-cache 
Pragma: no-cache
```
<br>

**Trailer**会事先说明在报文主体后记录了哪些首部字段

**Transfer-Encoding**规定了传输报文主体时采用的编码方式

**Upgrade**用于检测HTTP协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议

因为Upgrade首部字段产生作用的对象仅限于客户端和邻接服务器之间，所以使用首部字段Upgrade时，还需要额外指定```Connection:Upgrade```

**Via**是为了追踪客户端和服务器之间的请求和响应报文的传输路径。报文经过代理或网关时，会先在首部字段Via中附加该服务器的信息，然后再进行转发。它不仅可以追踪报文的转发，还可以避免请求回环的发生

**Warning**是从HTTP/1.0的响应首部（Retry-After）演变过来的，其格式如下：
```Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])```日期时间可以省略

HTTP/1.1定义了七种警告，警告码具有拓展性，可能之后追加新的警告码

|警告码|警告内容|说明|
|--|--|--|
|110|Response is stale（响应已过期）|代理返回已过期的资源|
|111|Revalidation failed（再验证失败）|代理再验证资源有效性时失败（服务器无法到达等原因）|
|112|Disconnection operation（断开连接操作）|代理与互联网连接被故意切断|
|113|Heuristic expiration（试探性过期）|响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）|
|199|Miscellaneous warning（杂项警告）|任意的警告内容|
|214|Transformation applied（使用了转换）|代理对内容编码或媒体类型等执行了某些处理时|
|299|Miscellaneous persistent warning（持久杂项警告）|任意的警告内容|
<br>

* **
* ### 请求首部字段

**Accept**首部字段可以通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可以使用type/subtype的形式指定多个媒体类型
|媒体类型| 格式 |
|--|--|
| 文本文件 | **text/html,text/plain,text/css... application/xhtml+xml,application/xml...** |
| 图片文件 | **image/jpeg,image/gif,image/png...** |
|视频文件|**video/mpeg,video/quicktime...** |
| 应用程序使用的二进制文件 | **application/octet-stream,application/zip...** |
<br>

如果想给显示的媒体类型加优先级，就用q=来额外表示权重值，用分号（；）进行分隔，q的范围是0~1，可以精确到小数点后三位

**Accept-Charset**首部字段可以用来通知服务器用户代理支持的字符集和字符集相对优先顺序，和Accept一样用q表示相对优先集。该首部字段应用于内容协商机制的服务器驱动协商

**Accept-Encoding**首部字段告知服务器用户代理支持的内容编码及内容编码的优先级顺序，如：**gzip**（由文件压缩程序gzip（GNU zip）生成的编码格式，采用Lempel-Ziv算法和32位循环冗余校验）、**compress**（由UNIX文件压缩程序compress生成的编码格式，采用LempelZiv-Welch算法（LZW））、**deflate**（组合使用zlib格式及由deflate压缩算法生成的编码格式）、**identity**（不执行压缩或不会变化的默认编码格式）

**Accept-Language**首部字段用于告知服务器用户代理能够处理的自然语言集，和自然语言集的相对优先级，一样用权重值q表示。格式如：```Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3```

**Authorization**首部字段是用来告知服务器用户代理的认证信息。通常想要通过服务器认证的用户代理会在接收到返回的401状态码响应后，把首部字段Authorization加入请求中

**Expect**首部字段用来告知服务器期望出现的某种特定行为。如果服务器无法理解客户端的期望做出回应而发生错误时，会返回状态码417 Expectation Failed

客户端可以利用该首部字段， 写明所期望的扩展。虽然 HTTP/1.1 规范只定义了100-continue（状态码100 Continue之意）。等待状态码100响应的客户端在发生请求时，需要指定Expect:100- continue

**From**首部字段用来告知服务器使用用户代理的用户电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式

**Host**首部字段用于区分运行在同一个IP上的虚拟主机。Host首部字段是HTTP/1.1规范内唯一一个必须被包含在请求内的首部字段。其格式如：```Host:www.hackr.jp```

**If-Match**首部字段，形如If-XXX这样形式的请求首部字段都可以称为条件请求，只有服务器判断指定条件为真时才会执行请求

只有当If-Match的字段值跟ETag值匹配一致时，服务器才会接受请求，否则返回状态码412 Precondition Failed的响应

（还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略ETag的值，只要资源存在就处理请求）

**If-Modified-Since：** 如果在其指定的日期时间之后资源发生了更新，服务器会接受请求。如果该时间之后资源都没有更新，则返回状态码304 Not Modified的响应

**If-None-Match**首部字段和If-Match作用相反

**If-Range**首部字段属于附带条件之一，它告知服务器若指定的If-Range字符值（Etag值或者时间）和请求资源的一致时，则作为范围请求处理，否则返回全部资源

**If-Unmodified-Since**首部字段的作用和If-Modified的作用相反

**Max-Forwards：** 通过TRACE方法或OPTIONS方法， 发送包含首部字段MaxForwards的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards的值减1后重新赋值。当服务器接收到Max-Forwards值为0的请求时，则不再进行转发，而是直接返回响应

使用该首部字段可以调查传输路径的通信状况

**Proxy-Authorization：** 当收到代理服务器发来的认证质询时，客户端会发送包含该首部字段的请求，告知服务器认证需要的信息。（这个认证行为在客户端和代理之间，客户端和服务器之间的认证用Authorization首部字段）

**Range**首部字段用于只需获取部分资源的范围请求，收到带该首部字段请求的服务器会在处理请求后返回状态码206 Partial Content的响应。如果无法处理该请求，就会返回200 OK并返回全部资源

**Referer**首部字段会告知服务器请求的原始资源的URI。但可能会有安全性问题，可以考虑不发送该首部字段。（顺便它的正确拼写应该是Referrer，但大家都用这个错误的拼写）

**TE**首部字段会告知服务器客户端能够处理响应的传输编码和相对优先级（也是q），和Accept-Encoding功能很香，但是用于传输编码

它除了指定传输编码，还可以指定伴随trailer字段的分块传输编码方式，只需把trailers赋值给字段值

**User-Agent**用于传达浏览器的种类，它会将浏览器和用户代理名称传达给服务器。由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。如果请求经过代理，中间也可能加上代理服务器的名称
* **
* ### 响应首部字段

**Accept-Ranges**首部字段用来告知客户端服务器能否处理范围请求，以指定获取服务器端某个部分的资源。可指定的值有两种：**bytes（可处理范围请求时）**、**none**

**Age**首部字段告知客户端源服务器在多久前创建了响应，单位为秒。如果是缓存服务器创建该响应，那么其值指的是缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段Age

**Etag**首部字段能告知客户端实体标识，是一种可将资源以字符串形式做唯一性标识的方式，服务器会为每份资源分配Etag值

资源更新时Etag值也需要更新，没有生成Etag统一的算法规则，仅仅由服务器分配

Etag值有强弱之分，强Etag值不管实体发生了多么细微的变化都会改变其值。弱Etag值只用于提示资源是否相同，只有资源发生了根本改变产生强烈差异时才会改变Etag值。这时会在字段值最开始时附加```W/```

**Location**首部字段可以将响应接收方引导至某个和请求URI不同的资源，该字段会配合3xx重定向响应。几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问

**Proxy-Authenticate**首部字段会把由代理服务器所要求的认证信息发送给客户端

它与客户端和服务器之间的HTTP访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间进行认证时，首部字段WWW-Authorization有着相同的作用

**Retry-After**首部字段告知客户端应该在多久之后再次发送请求，主要配合503 Service Unavailable或3XX Redirect一起使用

字段值可以是具体的时间日期，也可以是创建响应后的秒数

**Server**首部字段告知客户端当前服务器上安装的HTTP服务器应用程序的信息，不止标出服务器上软件应用名称，还有可能包括版本号和安装时启用的可选项

**Vary：** 当代理服务器收到带有Vary首部字段指定获取资源的请求时，如果使用的Accept-Language字段的值相同，那么就直接从缓存返回响应，否则就要从源服务器获取资源此案作为响应返回

首部字段Vary可对缓存进行控制。从代理服务器接收到源服务器返回包含Vary指定项的响应之后，若再要进行缓存，仅对请求中含有相同Vary指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于Vary指定的首部字段不相同，因此必须要从源服务器重新获取资源

**WWW-Authenticate**首部字段用于HTTP访问认证，告知客户端适用于访问请求URI所指的资源的认证方案和带参数提示的质询，状态码401 Unauthorized响应中一定带有该首部字段
* **
* ### 实体首部字段

**Allow**首部字段用于通知客户端能够支持Request-URI指定资源的所有HTTP方法。当服务器接收到不支持的HTTP方法时会以状态码405 Method Not Allowed作为响应返回，还会把所有支持的HTTP方法写入Allow中返回

**Content-Encoding**首部字段会告知客户端服务器对实体的主体部分选用的内容编码方式（各方式看Accept-Encoding的笔记）

**Content-Language**首部字段会告知客户端实体主体使用的自然语言

**Content-Length**首部字段表明了实体主体部分的大小，单位是字节。对实体部分进行编码传输时，不能使用该首部字段

**Content-Location**首部字段给出报文主体部分相对应的URI。和Location不同，它表示的是报文主体返回资源对应的URI。

对于使用首部字段Accept-Language的服务器驱动型请求，当返回的页面内容和实际请求对象不同时，它会写明URI

**Content-MD5：** 客户端会对接收的报文主体执行相同的MD5算法，然后和该首部字段的字段值相比较，目的在于检查报文主体在传输过程中是否保持完成以及确认传输到达

**Content-Range：** 针对范围请求，返回响应时使用的首部字段Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小

**Content-Type**首部字段说明了实体主体内对象的媒体类型，和首部字段Accept一样，字段值用type/subtype形式赋值。其格式如下：
```Content-Type: text/html; charset=UTF-8```
参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值

**Expires**首部字段会将资源失效日期告诉客户端。缓存服务器在接收到含有该首部字段的响应后会以缓存来应答请求，在其指定的时间之前响应的副本会一直被保存。如果超过了时间，缓存服务器收到请求时会转向源服务器请求资源

源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。如果Cache-Control有max-age指令时，会先处理max-age指令

**Last-Modified**首部字段指明资源最终修改的时间

* **
* ### 为Cookie服务的首部字段

虽然Cookie没有被编入标准化的HTTP/1.1的RFC2616中，但在Web网站有广泛的应用

Cookie的工作机制是用户识别和状态管理，调用Cookie时因为可以校验Cookie的有效期和发送方的域、路径、协议等信息，正规发布的Cookie内的数据不会因为其他Web站点的攻击而泄露

为Cookie服务的首部字段有**Set-Cookie**和**Cookie**

**Set-Cookie**是响应首部字段，当服务器准备开始管理客户端的状态时会事先告知各种信息。其属性有：
|属性|说明|
|--|--|
|**NAME=VALUE**|赋予Cookie的名称和其值（必需项）|
|**expires=DATE**|Cookie的有效期（若不明确指定则默认为浏览器关闭前为止）|
|**path=PATH**|将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）|
|**domain=域名**|作为Cookie适用对象的域名（若不指定则默认为创建Cookie的服务器的域名）|
|**Secure**|仅在HTTPS安全通信时才会发送 Cookie|
|**HttpOnly**|加以限制，使Cookie不能被JavaScript脚本访问|

**expires属性**指定浏览器可发送Cookie的有效期，如果省略就代表有效期仅限于维持浏览器会话的时间段内。一旦Cookie通过服务器发送至客户端，服务器端就不存在可显式删除Cookie的方法，但可以覆盖已过期的Cookie实现对客户端Cookie的实质删除

**path属性**限制指定Cookie的发送范围的文件目录。但有办法避开这个限制，不能对安全性抱怨期待

**domain属性：** 通过Cookie的domain属性指定的域名可做到与结尾匹配一致（指定example.com后，除example.com以外，www.example.com或www2.example.com等都可以发送 Cookie）。所有除了针对具体指定的多个域名发送Cookie之外，不指定domain属性更安全

**secure属性**用于限制 Web 页面仅在HTTPS安全连接时，才可以发送Cookie。如```Set-Cookie: name=value; secure```就是只有在https://www.example.com/（HTTPS）安全连接的情况下才会进行Cookie回收，即使域名相同，http://www.example.com/（HTTP）不会发生回收Cookie的行为

如果省略这个属性那就一律回收了

**HttpOnly属性**是Cookie的扩展功能，主要是防止JavaScript跨站脚本攻击信息窃取Cookie。Web页面内还可以对Cookie读取，但JS里的document。cookie就无法读取内容

**Cookie：** 首部字段Cookie会告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie。接收到多个Cookie时，同样可以以多个Cookie形式发送

* **
* ### 其他首部字段

HTTP的首部字段是可以自行扩展的，所有会出现各种非标准的首部字段，以下是一些常见的首部字段：

1. **X-Frame-Options**
属于HTTP响应首部，控制网站内容在其他Web网站的Frame标签内的显示问题。主要是防止点击劫持攻击<br><br>它有两个可指定的字段值：**DENY（拒绝）**、**SAMEORIGIN（仅同源域名下的页面）**
2. **X-XSS-Protection**
属于HTTP响应首部，是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关<br><br>它有两个可指定的字段值：**0：将 XSS 过滤设置成无效状态**、**1：将 XSS 过滤设置成有效状态**
3. **DNT**
属于HTTP请求首部，是Do Not Track的简称，拒绝被精确广告追踪的一种方法<br><br>它有两个可指定的字段值：**0：同意被追踪**、**1：拒绝被追踪**
4. **P3P**
属于HTTP响应首部，可以使Web网站上的个人隐私变成一种仅供程序可以理解的形式，保护用户隐私<br><br>要进行P3P设定，首先要创建P3P隐私，然后创建P3P隐私对照文件后，保存命名在 /w3c/p3p.xml，最后从P3P隐私中新建Compact policies后，输出到HTTP响应中
* **
* ## 第七章 确保Web安全的HTTPS

HTTP协议中有可能存在信息窃听或身份伪装等安全问题，但也可以得到解决

HTTP的不足点如下：

1. **使用通信明文，内容可能被窃听**
由于HTTP本身不具备加密功能，无法做到对通信整体进行加密。按TCP/IP协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。即使加密了报文，虽然可能让人无法破解报文信息，但报文本身还是会被看到<br><br>窃取相同段上的通信只需要收集互联网上流动的数据包即可，可以利用抓包或嗅探器工具进行收集<br><br>目前研究如何防止窃听的方法中，最为普及的就是加密技术，可以加密的对象有那么几个：
   1. **通信加密**，通过SSL（安全套接层）或TLS（安全层传输协议）的组合使用加密HTTP通信内容。用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP称为HTTPS
   2. **内容加密**，把HTTP协议传输的内容本身加密。在这种情况下，客户端需要对HTTP报文进行加密处理后再发送请求。但要使加密有效需要让客户端和服务器端同时具备加密和解密机制，而且内容仍然有被篡改的风险
2. **不验证通信方的身份，有可能遭遇伪装**
HTTP协议中的请求和响应不会对通信方进行确认。任何人都可以发起请求，服务器也不管对方是谁都会返回一个响应（仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下）。但是不确认通信方会存在各种隐患，如**无法确认目标服务器是否是伪装的服务器；无法确认收到响应是否是伪装的客户端；无法确定正在通信的对方是否具有访问权限；无法确定请求来自哪里，是谁发起的；即使是无意义的请求也会接收（DoS攻击）**<br><br>虽然HTTP协议无法确认通信方，但使用SSL却可以，SSL不仅提供加密处理，还使用了一种名为证书的手段。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是真实存在的，伪造证书从技术角度来说很难做到
3. **无法证明报文的完整性**
完整性是指信息的准确度，如果无法证明完整性也就意味着无法判断信息是否准确<br><br>再请求或响应送出到对方接收这段时间，即使内容遭到篡改也没有办法获悉。再响应或传输的途中遭攻击者拦截并且篡改内容的攻击称为**中间人攻击（Man-in-the-Middle attack，MITM）**<br><br>虽然有使用HTTP协议确定报文完整性的方法，但这种方法并不便捷可靠。最常用的方法是**MD5**和**SHA-1**等散列值校验的方法，还有用来确认文件的数字签名方法<br><br>但这些方法也不是百分百确认结果正确，因为如果方法本身被改写用户也没法意识到，为了解决这些弊端就有必要使用HTTPS

**HTTPS=HTTP+加密+认证+完整性保护**

经常会在Web的登陆页面和购物结算页面等使用HTTPS通信，使用HTTPS通信时不再使用http://而是https://。而且地址栏里会出现一个带锁的标记

HTTPS并非是应用层的一种新协议，只是HTTP接口部分用SSL和TLS协议代替。通常HTTP直接和TCP通信，但是使用HTTPS时，它会先和SSL通信，SSL再和TCP通信。采用SSL后，HTTP就有了HTTPS的加密、证书、完整性保护这些功能

SSL是独立HTTP的协议，可以配合其他协议使用，可以说它是当今世界上应用最广泛的网络安全技术

SSL采用一种叫做**公开密钥加密**的方法

近代的加密方法中加密算法是公开的，但密钥是保密的，这种方式可以保持加密算法的安全性

如果是**共享密钥加密（对称密钥加密）**，那么就会遇到一个很矛盾的问题：你要想接收方能够解密，就得把密钥也一起发送，这也就意味着攻击方也可以获得密钥，那么加密就失去了意义。如果密钥能安全的到接收者手中，那数据本来就可以安全送达，就不需要加密。此外还得设法安全保管密钥

**公开密钥加密**就很好地解决了这个问题。它使用一种非对称的密钥，一把叫做**私有密钥**，一把叫做**公开密钥**。使用该方法进行通信时，发送密文的一方使用对方的公开密钥进行加密，对方收到信息后用私有密钥进行解密，这样就不需要发送解密的私有密钥了

想要根据密文和公开密钥恢复到信息原文是相当困难的，因为当下技术不能做到对一个非常大的整数进行快速的因式分解

HTTPS采用**混合加密机制**，也就是说它采用共享密钥加密和公开密钥加密两者并用的混合加密机制。如果密钥能实现安全交换就有可能考虑仅使用公开密钥加密来通信，但是公开密钥加密处理速度要慢

所以将两者各自的优势结合，在交换密钥时采用公开密钥加密，之后的通信使用共享密钥加密

遗憾的是公开密钥加密还是存在漏洞，就是无法证明公开密钥是否被攻击者替换掉。为了解决这个问题就可以使用数字证书认证机构和其相关机构颁发的公开密钥证书，其业务流程如下：

1. 服务器运营人员向数字证书认证机构提出公开密钥的申请
2. 机构在判明申请者的身份后会对已申请的公开密钥做数字签名
3. 分配这个已签名的公开密钥，将该密钥放入公钥证书后绑定在一起

然后服务器会将这份由数字证书认证机构办法的公钥证书发送给客户端。客户端收到后对证书上的数字签名进行验证，一旦验证提供，客户端便知道**认证服务器的公开密钥的是真实有效的数字证书认证机构**和**服务器的公开密钥是值得信赖的**

此处的公开密钥必须安全转交给客户端，所有多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥

EV SSL证书可以确认对方服务器背后运营的企业是否真实存在。它是基于国际标准的认证指导方针颁发的证书，通过认证的Web网站能获得更高认可度。持有该证书的网站浏览器地址栏处的背景色是绿色的，而且在地址栏的左侧显示了 SSL证书中记录的组织名称以及颁发证书的认证机构的名称

HTTPS中还可以使用客户端证书，作用和服务器差不多，用于服务器确认通信的对方是预料之内的客户端。但这个也不能用来证明用户本人的真实有效性

**认证机构的信誉十分重要**，如果数字签名被伪造那么证书就会被判定为正当的，会造成利益损失

如果使用OpenSSL这套开源程序，每个人都可以构建属于自己的认证机构，给自己的服务器颁发证书，在互联网上不可做为证书使用，只能自己玩玩

HTTPS的通信步骤如下：

1. 客户端发送Client Hello报文开始SSL通信，其中包含客户端支持的SSL指定版本，加密组件列表
2. 服务器可进行SSL通信时，会以Server Hello报文作为应答，也会在报文里包含SSL版本和加密组件（服务器的加密组件内容是从客户端发来的加密组件列表里筛选出来的）
3. 服务器发送Certificate报文，报文中包含公开密钥证书
4. 服务器发送Server Hello Done报文通知客户端，SSL握手协商部分结束
5. SSL第一次握手结束后，客户端以Client Key Exchange报文进行回应，其中包含通信加密中使用的一种被称为Pre-master secret的随机密码串，已经使用公开密钥进行加密
6. 客户端继续发送Change Cipher Spec报文以提示服务器，在此报文之后的通信采用Pre-master secret密钥进行加密
7. 客户端发送Finished报文，其中包含至今全部报文的整体校验值，此次握手协商的成功与否要以服务器能否正确解密该报文作为前提
8. 服务器同样发送Change Cipher Spec报文
9. 服务器同样发送Finished报文
10. 两边Finished报文交换完毕之后，SSL连接建立完成，此处开始进行应用层协议的通信，即发送HTTP请求 
11. 发送HTTP响应
12. 由客户端断开连接，发送close_notify报文，然后再发送TCP FIN报文以关闭TCP通信
<br>

在上面流程中应用层发送数据时会附加叫**MAC（Message Authentication Code）** 的报文摘要，用于查知报文是否遭到篡改

HTTPS的速度要比HTTP慢2~200倍。SSL的慢分两种：**通信慢和处理速度慢**，要进行SSL通信整体上处理的通信量会不可避免的增加。而且SSL必须进行加密处理，客户端和服务器都要进行加密和解密的运算处理，导致负载增强。由于这些原因，只要通信信息包含个人信息等敏感数据时才使用HTTPS加密通信（而且证书也贵）
* **
* ## 第八章 确认用户身份的认证

计算机本身无法判断坐在显示器前的是谁，也无法确认网络那头的人是谁。为了弄清楚是谁在访问服务器，就得让对方客户端自报家门。为了确认对方是否有访问权限，就得确认对方是否有“登录者本人才知道的信息”，如：

1. **密码：** 只有本人才会知道的字符串信息
2. **动态令牌：** 仅限本人持有的设备内显示的一次性密码
3. **数字证书：** 仅限本人（终端）持有的信息
4. **生物认证：** 指纹和虹膜等本人生理信息 
5. **IC卡等：** 仅限本人持有的信息

HTTP/1.1的认证方式：

1. **BASIC认证（基本认证）**
2. **DIGEST认证（摘要认证）**
3. **SSL客户端认证**
4. **FormBase认证（基于表单认证）**

**BASIC认证步骤：**

1. 当请求的资源需要BASIC认证时，服务器会随状态码401 Authorization Required返回带WWW-Authenticate首部字段的响应，其中包含认证方式（Basic）和Request-URI安全域字符串
2. 收到该响应的客户端为了通过BASIC认证，需要将用户ID和密码发送给服务器。字符串内容是经过Base64编码处理的用冒号隔开的ID和密码
3. 在接收到包含首部字段Authorization首部字段的请求后会对认证信息的正确性进行验证，如果通过就返回包含Request-URI资源的响应

BASIC认证虽然采取了Base64编码方式，但是这不是加密处理，在HTTP等非加密线路上进行BASIC认证如果被窃听，被盗的可能性很高。而且如果还想再进行一次BASIC认证的话，一般的浏览器无法实现注销操作

**DIGEST认证：**

为了弥补BASIC认证的缺点，从HTTP/1.1起就有了BASIC认证，它同样采用质询/响应的方式，但不会直接明文发送密码

其认证步骤如下：

1. 请求需要认证的资源时，服务器会随状态码401 Authorization Required返回带WWW-Authenticate首部字段的响应，其中包含认证方式（Digest）和质问响应方式认证所需的临时质询码（随机数，nonce）<br><br>**nonce**是每次返回401响应生成的随机任意字符串
2. 接收到401状态码的客户端，返回的响应中包含DIGEST认证必须的首部字段Authorization信息，其中包含**username、 realm、 nonce、 uri、response**的字段信息，realm和nonce就是之前从服务器接收到的响应中的字段<br><br>**uri**就是Request-URI的值，防止代理转发后Request-URI的值可能会被修改，会事先复制一份副本保存在uri内<br><br>**response**可以叫做Request-Digest，存放经过MD5运算后的密码字符串形成响应码
3. 接收到包含首部字段Authorization请求的服务器，会确认认证信息的正确性。认证通过后则返回包含Request-URI资源的响应

DIGEST安全性比BASIC要高，但是相比HTTPS还是很弱。DIGEST提供防止密码被窃听的保护机制，但不存在防止用户伪装的保护机制，而且用起来也不是很便捷，以适用范围也不大

**SSL客户端认证：**

SSL客户端认证可以避免用户ID和密码被盗从而被第三者冒充的情况

SSL客户端认证是借由HTTPS客户端证书完成认证的方式。其步骤如下：

1. 接收到认证请求，服务器发送Certificate Request报文，要求客户端提供客户端证书
2. 用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate报文方式发送给服务器
3. 服务器验证客户端证书通过后才能领取证书内的客户都安的公开密钥，开始HTTPS加密通信

一般来说SSL客户都安认证不会仅依靠证书来完成认证，会和基于表单认证组合成一种双因素认证。SSL客户都安认证确认这是客户端计算机，另一个认证用来确认这是用户本人的行为

**基于表单认证：**

该认证方法并不是在HTTP协议中定义的。客户端向服务器的Web应用程序发送登录信息，按登录信息的验证结果进行认证

因为使用时的便捷性和安全性问题，BASIC和DIGEST认证几乎不怎么使用，SSL客户端认证虽然安全等级高，但是因为导入和费用高还没普及

表单认证不具备共同规范，如果经过全面考虑，那么安全等级很高。

基于表单认证的标准规范尚未定论，一般用Cookie来管理会话（Session）

基于表单认证本身是通过服务器端的Web应用，将客户端发送过来的用户ID和密码与之前登陆过的信息匹配来认证的

但之前也提到过HTTP是无状态协议，不会对状态进行保存。所有我们使用Cookie来管理会话：

1. 客户端把用户ID密码放入报文实体部分，通常用POST方法把请求传给服务器，会使用HTTPS来显示HTML表单和发送数据
2. 服务器发放用来识别用户的Session ID，写在响应的Set-Cookie首部字段内（为了防止被盗或被猜出服务器要进行有效期管理，并使用难以猜测的字符串。并且为了防止跨站脚本攻击，要在Cookie里加上httponly属性）
3. 客户端收到Session ID后将其作为Cookie保存在本地，发送请求时浏览器会自动发送Cookie


（基于表单认证的登录信息和认证过程都没有标准化的方法，而且就连服务器端怎么保存用户提交的密码也没有标准化的方法。通常一种安全的保存方法是先给密码加盐（salt），然后利用散列（hash）函数计算出散列值后保存。明文保存也很常见，但会有泄露的风险）

（另：加盐就是由服务器随机生成一个很长的字符串，与密码字符串相连接然后计算散列值，这样即使两个用户的密码是一样的散列值也会不同，很大程度上减少了密码特征）
* **
* ## 第九章 基于HTTP的追加功能

随着时代的发展，HTTP功能上的不足已经逐渐显现，于是就有了一些基于HTTP的新协议，在HTTP的基础上添加了新功能

**SPDY**是由Google在2010年发布的，其开发目标旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间（50%）

**HTTP的瓶颈：** 在一些SNS网站上，很短的时间就会产生大量的请求。为了尽可能地实时反馈这些更新内容，服务器上一有内容更新就需要直接把那些内容反馈到客户端界面。如果使用HTTP协议探知更新，就需要频繁地向服务器端确认，会产生大量徒劳的通信

如果想实现这些功能，有些HTTP标准会成为瓶颈：

1. 一条连接上只可发送一个请求
2. 请求只能从客户端开始，客户端只能接收响应指令
3. 请求 / 响应首部未经压缩就发送。首部信息越多延迟越大
4. 每次互相发送相同的首部造成的浪费较多
5. 可以任意选择压缩格式，非强制压缩
<br>

**Ajax（Asynchronous JavaScript and XML，异步JavaScript与XML技术）** 有效利用了JS和DOM（Document Object Model，文档对象模型）的操作，达到局部Web页面替换加载的异步通信手段，和之前的同步通信相比因为只传输一部分页面所有传输数据量变少

其核心技术是叫做XMLHttpRequest的API，通过JavaScript脚本语言的调用就能和服务器进行HTTP通信，从而在已经加载完毕的Web页面上发起请求，只更新局部页面

但是使用Ajax实时从服务器获取内容，有可能会导致大量请求产生，它也没有解决HTTP协议本身存在的问题

**Comet**不会让请求等待服务器内容更新，而是已有资源更新直接向客户端返回响应，通过延迟应答模拟服务器端向客户端推送的功能

通常服务器都是立刻处理请求并返回响应，但为了实现推送功能，Comet将响应处于挂起状态，一旦服务器有资源更新，再返回响应。虽然做到了实时更新，但是一次连接的持续时间也变长了，会消耗更多资源，同时它也没有解决HTTP协议本身存在的问题

虽然这两个办法一定程度上使HTTP得到了改善，但没有消除HTTP的瓶颈，处于持续开发中的SPDY正是为了在协议级别消除HTTP所遭遇的瓶颈

**SPDY**没有完全改写HTTP协议，而是在TCP/IP的应用层和运输层直接通过新加**会话层**的形式运作，同时考虑到安全性，它规定通信中使用SSL

SPDY以会话层形式加入，控制对数据的流动，但还是采用HTTP建立通信连接。在使用SPDY后，HTTP协议额外获得以下功能

1. **多路复用流**
通过单一的TCP连接，可以无限制处理多个HTTP请求。所有请求在一条TCP连接上完成，处理效率高
2. **赋予请求优先级**
SPDY不仅可以无限制地并发请求，还可以给请求赋予优先级顺序，这样可以在发送多个请求时解决因宽带低导致的响应变慢
3. **压缩HTTP首部**
压缩请求和响应的HTTP首部，减少发送的字节数
4. **推送功能**
支持服务器向客户端推送，不必等待客户端请求
5. **服务器提示功能**
服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。

**WebSocket**是HTML5标准的一部分，现在它逐渐变成了独立的协议，它是为了解决Ajax和Comet里XMLHttpReques附带的缺陷所引起的问题

一旦服务器和客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。

因为是建立在HTTP基础上的协议，所有连接的发起方仍然是客户端，但是一旦WebSocket通信建立，不管是哪一方都可以直接向对方发送报文

其特点如下：

1. **推送功能**
服务器直接向客户端发送数据的推送功能，不必等待客户端请求
2. **减少通信量**
只要建立起WebSocket连接， 就希望一直保持连接状态，并且其首部信息很小
<br>
为了完成WebSocket通信，需要在HTTP连接建立后完成“握手”的步骤，**请求**时用Upgrade首部字段告知服务器通信协议发生改变，达到握手的目的

Sec-WebSocket-Key字段内记录着握手过程中必不可少的键值。Sec-WebSocket-Protocol字段内记录使用的子协议

对应之前的请求，**响应**返回状态码101 Switching Protocols

成功握手确立WebSocket连接之后， 通信时不再使用 HTTP 的数据帧， 而采用WebSocket独立的数据帧

HTTP/2.0的七项技术讨论：
|||
|--|--|
|压缩|SPDY、 Friendly|
|多路复用|SPDY|
|TLS 义务化|Speed＋ Mobility|
|协商|Speed＋ Mobility， Friendly|
|客户端拉曳（Client Pull） /服务器推送（Server Push）|Speed＋ Mobility|
|流量控制|SPDY|
|WebSocket|Speed＋ Mobility|
<br>

**WebDAV** 是一个可以对Web服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。它作为扩展HTTP/1.1协议定义在RFC4918

除了上面的基本功能，它还能进行文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能，还有对文件修改的版本控制功能

WebDAV针对服务器上的资源做了一些概念扩展：

1. **集合**是一种统一管理多个资源的概念，以集合为单位可以进行各种操作，集合也可以嵌套
2. **资源**是指文件或集合
3. **属性：** 资源属性的定义以“名称=值”的格式执行
4. **锁**会把文件设置成无法编辑状态，多人同时编辑时可以防止在同一时间进行内容写入

WebDAV为了实现远程资源管理，还向HTTP/1.1追加了一些方法和状态码：
|方法| 描述 |
|--|--|
| **PROPFIND** | 获取属性 |
| **PROPPATCH** | 修改属性 |
|**MKCOL**  | 创建集合 |
| **COPY** | 复制资源和属性 |
| **MOVE** | 移动资源 |
| **LOCK** | 资源加锁 |
| **UNLOCK** | 资源解锁 |

| 状态码 | 描述 |
| -- | --|
|**102 Processing**|可正常处理请求， 但目前是处理中状态|
|**207 Multi-Status**|存在多种状态|
|**422 Unprocessible Entity**|格式正确，内容有误|
|**423 Locked**|资源已经被上锁|
|**424 Failed Dependency**|处理与某请求关联的请求失败，不再维持依赖关系|
|**507 Insufficient Storage**|保存空间不足|

* **

 * # 代码部分

后面的想法就是做个导航栏还有下面色彩选择的部分希望能选择一个色彩展示人物相关信息
看考核要求最后说不定还能加个问卷？
* ## html文档 
```
<!DOCTYPE html>

<html lang="en">

  

<head>

<meta charset="UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>fuhuo</title>

<link rel="stylesheet" href="./css/style.css">

<link rel="stylesheet" href="./css/color.css">

<style>

</style>

</head>

  

<body>

<script src="./js/1.js"></script>

<img src="2.png" alt="偶像大师闪耀色彩标题" id="tphoto">

<div class="bjtp"></div>

<div id="topicbox">

</div>

<div id="box0">

<b id="topic">fuhuo的偶像大师闪耀色彩试验性demo</b>

</div>

<div id="background">

<div class="box1">

<img src="283.png" alt="283PRO标志" id="bz" style="user-select: none;">

<h1 id="biaoyucn">闪耀吧，让偶像的一切</h1>

<h1 id="biaoyu">輝かせよう、アイドルのすべて</h1>

</div>

<div class="jieshao">本demo旨在通过实操的方式学习前端相关知识，因为是边学边做，所以程序可能比较混乱，但有稍微整理过。</div>

<div class="jianjie">

<div style="border-left: 10px solid greenyellow ;">

<h1 style="color: aqua;">简介</h1>

</div>

<h2>你说的对，但————</h2>

<a href="https://shinycolors.enza.fun/" target="_blank"><img src="283pro.png" alt="283PRO场景" class="283pro"

width="400px" style="float: right;" title="点击进入283PRO"></a>

<ul>

<li>《偶像大师闪耀色彩》（アイドルマスター

シャイニーカラーズ）是由万代南梦宫NEXUS（前身为BXD）旗下的enza平台开发的一款模拟养成类抽卡社交网页游戏，为偶像大师系列作品之一，于2018年4月24日开始运营。</li>

<p></p>

<li>《偶像大师闪耀色彩》背景设定在东京都的283事务所(283谐音“翅膀”)。玩家将培养和管理偶像，参与各种活动和演出。游戏特色在于其与现实时间同步的季节变化，以及丰富的剧情和角色成长系统。玩家可以在一个充满生活气息的环境中，体验偶像的成长和挑战。游戏的UI设计贴近现实，让玩家仿佛置身于偶像的日常生活之中。通过玩家的选择和互动，偶像们将经历各种故事线，展现不同的成长和变化。《偶像大师闪耀色彩》（アイドルマスター

シャイニーカラーズ）是由万代南梦宫NEXUS（前身为BXD）旗下的enza平台开发的一款模拟养成类抽卡社交网页游戏，为偶像大师系列作品之一，于2018年4月24日开始运营。</li>

</ul>

</div>

<div class="box2">

<div style="border-left: 10px solid rgb(0, 26, 255) ;">

<h3>目前283PRO共有:</h3>

</div>

<h1 style="font-size: 60px ; font-style: italic; padding-left: 260px; position: relative; top: 0%;

left: 50%;

transform: translate(-50%, -75%); user-select: none;" class="ho" id="qhs">28colors

</h1>

</div>

<div><button class="qk" onmouseover="qingkong()">清空选择</button></div>

<div>

<table class="colors">

<tr>

<th colspan="3"><img src="zh/xing.png" alt="" class="zh"></th>

<th colspan="5"><img src="zh/ant.png" alt="" class="zh"></th>

</tr>

<tr >

<th>

<div class="checkboxs">

<div class="checkbox-container" id="mano" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="jiaozi" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="mgr" onmouseover="xuanzhong()"></div>

</div>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="kgn" onmouseover="xuanzhong()"></div>

</div>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="mmm" onmouseover="xuanzhong()"></div>

</div>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="sky" onmouseover="xuanzhong()"></div>

</div>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="fff" onmouseover="xuanzhong()"></div>

</div>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="krk" onmouseover="xuanzhong()"></div>

</div>

</th>

</tr>

<tr>

<th colspan="5"><img src="zh/fkh.png" alt="" class="zh" style="height: 100px;"></th>

<th colspan="3"><img src="zh/hua.png" alt="" class="zh"></th>

</tr>

<tr>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="kaho" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="cyk" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="juri" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="rinze" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="nth" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="amn" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="tenka" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="chyk" onmouseover="xuanzhong()"></div>

</div>

</th>

</tr>

</table>

<table>

<tr>

<th colspan="3" style="height: 100px;"><img src="zh/sl.png" alt="" class="zh"></th>

<th colspan="4" style="height: 100px;"><img src="zh/noc.png" alt="" class="zh"></th>

</tr>

<tr>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="ash" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="fyk" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="mei" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="toru" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="mdk" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="koito" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="hnn" onmouseover="xuanzhong()"></div>

</div>

</th>

  

</tr>

</table>

<table>

<tr>

<th colspan="2"><img src="zh/ss.png" alt="" class="zh" style="height: 60px;"></th>

<th colspan="3"><img src="zh/co.png" alt="" class="zh"></th>

</tr>

<tr>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="nck" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="mkd" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="luka" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="hana" onmouseover="xuanzhong()"></div>

</div>

</th>

<th>

<div class="checkboxs">

<div class="checkbox-container" id="hrk" onmouseover="xuanzhong()"></div>

</div>

</th>

</tr>

</table>

</div>

</div>

  

</body>

  

</html>
```
* **
* ## css文档
### style.css
这里有做一个鼠标移动上去图片逐渐变换的效果，但html文档暂时还没用到。具体效果可见<https://mzh.moegirl.org.cn/%E5%81%B6%E5%83%8F%E5%A4%A7%E5%B8%88_%E9%97%AA%E8%80%80%E8%89%B2%E5%BD%A9>里“登场角色”栏中的效果
```
.hbg{

background-color: yellow;

}

.hl{

color: red;

}

.ho{

transition: color 1.2s ease-in-out;

}

.ho:hover{

color: #8adfff;

clear: both;

}

.ho{

position: relative; /* 为伪元素定位提供基础 */

cursor: pointer; /* 鼠标指针样式 */

}

  

.ho:hover::after {

content: '象征青空的企划色: . .#8adfff'; /* 显示的文字内容 */

position: absolute;

font-style: normal;

top: 60px; /* 调整伪元素垂直位置 */

right: 110px; /* 调整伪元素水平位置 */

color: black; /* 文字颜色 */

font-size: 12px; /* 字体大小 */

white-space: nowrap; /* 防止文字换行 */

}

  

.ho:hover::before {

content:'';

position: absolute;

top: 63px;

right: 155px;

width: 10px;

height: 10px;

background-color: #8adfff; /* 方块颜色 */

border: 1px solid #ccc; /* 可选边框 */

border-radius: 2px;

z-index: 10;

}

#bian{

height: 350px;

display: inline-block;

}

.idolphoto2,.idolphoto1{

width:200px ;

border: 10px solid silver ;

}

#bian:hover>.idolphoto1{

opacity: 1;

box-shadow: 5px 5px 10px rgb(0,0,0,0.5);

}

#bian:hover>.idolphoto2{

opacity: 0;

}

#bian>.idolphoto2,.idolphoto1{

transition: opacity 0.8s;

opacity: 1;

position: absolute;

top:850px;

}

#bian>.idolphoto1{

opacity: 0;

}

.bjtp {

position: fixed;

top: 0;

left: 0;

background-image: url("1.png");

background-size: cover;

height: 100%;

width: 100%;

}

  

.photo {

position: fixed;

left: 0px;

top: 0px;

z-index: -1;

user-select: none;

}

  

#topicbox {

display: flex;

height: 150px;

width: 1255px;

background-color: rgb(255, 255, 255);

z-index: 0;

filter: blur(30px);

top: 50px;

position: absolute;

}

  

#topic {

font-size: 50px;

color: black;

font-family: cursive;

position: absolute;

z-index: 1;

display: block;

user-select: none;

}

  

#background {

position: relative;

top: 200px;

margin-left: auto;

margin-right: auto;

width: 1000px;

z-index: 0;

background: rgba(236, 235, 233, 0.9);

padding-bottom: 100px;

}

  

#tphoto {

position: absolute;

width: 200px;

z-index: 2;

left: 553px;

top: 0px;

user-select: none;

}

  

#background .box1 {

height: 150px;

background: rgba(236, 235, 233, 0);

border-left: 10px solid rgb(0, 179, 255);

z-index: 1;

border-radius: 10px;

position: relative;

overflow: hidden;

margin-left: auto;

margin-right: auto;

top: 30px;

}

  

#background .box1 #bz {

float: left;

width: 120px;

margin-top: 10px;

clear: both;

}

  

#background .box1 #biaoyu {

display: block;

font-size: 50px;

font-style: italic;

text-align: center;

margin: 0px;

}

  

#background .box1 #biaoyucn {

display: block;

font-size: 50px;

font-style: italic;

font-family: "KaiTi";

text-align: center;

margin-top: 15px;

margin-bottom: 0px;

}

  

#background .jianjie {

background: rgba(255, 255, 255, 0.5);

width: 800px;

margin-left: auto;

margin-right: auto;

margin-top: 50px;

}

  

#background .box2 {

background: rgba(255, 255, 255, 0.5);

width: 800px;

height: 100px;

margin-left: auto;

margin-right: auto;

}

  

#box0 {

width: 1000px;

z-index: 2;

margin-left: 220px;

margin-top: 95px;

position: absolute;

}

  

.checkboxs {

display: inline;

flex-wrap: wrap;

align-items: center;

justify-content: flex-start;

flex: 1 1 auto;

}

  

.checkbox-container {

width: 100px;

color: #fff;

height: 100px;

min-width: 40px;

padding: 0 8px;

display: inline-flex;

flex: 0 0 auto;

align-items: center;

justify-content: center;

vertical-align: middle;

box-shadow: 0 3px 5px gray;

letter-spacing: .08em;

text-indent: .08em;

cursor: pointer;

}

  

.xz {

box-shadow:0 3px 10px black ;

}

  

table th {

border: 1px solid black;

}

  

.colors {

margin-top: 50px;

margin-right: auto;

margin-left: auto;

border-collapse: collapse;

}

  

table {

margin-right: auto;

margin-left: auto;

border-collapse: collapse;

table-layout:auto;

}

  

.xz1{

box-shadow:5px 8px 20px black ;

}

.qk{

border-radius: 5px;

background-color: #8adfff;

color: white;

position: absolute;

right:30px;

margin-top: 20px;

}

.jieshao{

margin-top: 80px;

width: 600px;

margin-left: auto;

margin-right: auto;

background-color: rgba(255, 255, 255, 0.5);

border-radius: 5px;

align-items: center;

justify-content: center;

border-left: 8px solid red;

font-size: 20px;

}

.zh{

height: 80px;

}

th{

height: 100px;

}
```
<br>

### colors
就是设置背景颜色的
```
#mano{

background-color: #FFBAD6;

}

#jiaozi{

background-color: #144384;

}

#mgr{

background-color: #FFE012;

}

#kgn{

background-color: #F84CAD;

}

#mmm{

background-color: #A846FB;

}

#sky{

background-color: #006047;

}

#fff{

background-color: #3B91C4;

}

#krk{

background-color: #D9F2FF;

}

#kaho{

background-color: #E5461C;

}

#cyk{

background-color: #F93B90;

}

#juri{

background-color: #FFC602;

}

#rinze{

background-color: #89C3EB;

}

#nth{

background-color: #90E667;

}

#amn{

background-color: #F54275;

}

#tenka{

background-color: #E75BEC;

}#chyk{

background-color: #FBFAFA;

}

#ash{

background-color: #F30100;

}

#fyk{

background-color: #5CE626;

}

#mei{

background-color: #FF00FF;

}

#toru{

background-color: #50D0D0;

}

#mdk{

background-color: #BE1E3E;

}

#koito{

background-color: #7967C3;

}

#hnn{

background-color: #FFC639;

}

#nck{

background-color: #A6CEB6;

}

#mkd{

background-color: #760F10;

}

#luka{

background-color: #24130D;

}

#hana{

background-color: #E0B5D3;

}

#hrk{

background-color: #EAD7A4;

}
```
<br>

## JavaScript文档
目前没怎么学，不太会用
### 1.js
```
var currentDate = new Date();

var Hour = currentDate.getHours();

console.log(Hour);

if(Hour>=6&&Hour<=12){

alert("早上好~制作人");

}else if(Hour>12&&Hour<=17){

alert("下午的工作也要加油哦，制作人");

}else if(Hour>17&&Hour<=23){

alert("晚上要不要去看星星呢~");

}else{alert("这么晚了还不睡觉，Mr.作息失调");}

  
  
  
  
  

function xuanzhong(){

document.querySelectorAll('.checkbox-container').forEach(function(box) {

box.addEventListener("click", function() {

document.querySelectorAll('.checkbox-container.xz1').forEach(function(selectedBox) {

selectedBox.classList.remove('xz1');

});

box.classList.add('xz1');

});

document.querySelectorAll('.checkbox-container').forEach(function(box) {

box.addEventListener("mouseover", function() {

document.querySelectorAll('.checkbox-container.xz').forEach(function(selectedBox) {

selectedBox.classList.remove('xz');

});

box.classList.add('xz');

});

box.addEventListener("mouseleave", function() {

document.querySelectorAll('.xz').forEach(function(selectedBox) {

selectedBox.classList.remove('xz');

});

});

}

)})}

  

function qingkong(){

var box=document.querySelector('.qk');

box.addEventListener("mousedown",function(){

document.querySelector('.qk').style.color="black";

document.querySelectorAll('.xz1').forEach(function(selectedBox) {

selectedBox.classList.remove('xz1');

});

})

box.addEventListener("mouseup",function(){

document.querySelector('.qk').style.color="white";

})

}
```
* **
## 图片部分
1.png
![1.png](https://www.project-imas.wiki/images/7/76/SC_S_Higuchi_Madoka_SR04.jpg)
<br>
2.png
![输入图片说明](https://www.project-imas.wiki/images/3/3a/THE_iDOLM@STER_Shiny_Colors_2023_Logo.png)
<br>
283.png
![输入图片说明](https://www.project-imas.wiki/images/2/22/283Pro_Logo.png)
<br>
283pro.png
![输入图片说明](https://www.project-imas.wiki/images/7/71/283.jpg)
<br>
* **
### zh文件夹
xing.png
![输入图片说明](https://www.project-imas.wiki/images/thumb/8/80/Illumination_STARS_logo.png/800px-Illumination_STARS_logo.png)
<br>
ant.png
![输入图片说明](https://www.project-imas.wiki/images/thumb/9/99/L%27Antica_logo.png/800px-L%27Antica_logo.png)
<br>
hua.png
![输入图片说明](https://www.project-imas.wiki/images/9/9d/Logo_ALSTROEMERIA.png)
<br>
fkh.png
![输入图片说明](https://www.project-imas.wiki/images/thumb/f/f0/Houkago_Climax_Girls_Logo.png/800px-Houkago_Climax_Girls_Logo.png)
<br>
sl.png
![输入图片说明](https://www.project-imas.wiki/images/2/23/STRAYLIGHT.png)
<br>
noc.png
![输入图片说明](https://www.project-imas.wiki/images/5/5b/Noctchill_unit_logo.png)
<br>
ss.png
![输入图片说明](https://www.project-imas.wiki/images/a/a3/SHHis_Unit_logo.png)
<br>
co.png
![输入图片说明](https://www.project-imas.wiki/images/6/6e/CoMETIK_Unit_logo.png)
