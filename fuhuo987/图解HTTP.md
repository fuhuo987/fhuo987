 [TOC]
 # 图解HTTP笔记
 * ## 第一章 了解Web及网络基础

Web使用一种名为HTTP(HyperText Transfer Protocol，超文本传输协议)的协议作为规范，完成从客户端到服务器端灯一系列运作流程，可以说，Web是建立在HTTP协议上通信的

CERN（欧洲核子研究组织）的蒂姆·伯纳斯-李博士提出了一种能让远隔两地的研究者们共享知识的设想

现在已经提出了三项WWW（World Wide Web，万维网）构建技术，分别是：
1. **HTML**（HyperText Markup Language，超文本标记语言），它的页面文本标记语言为SGML（Standard Generalized Markup Language，标准通用标记语言）
2. **HTTP**，作为文档传递协议
3. **URL**（Uniform Resource Locator，统一资源定位符）
<br>

CERN成功研发了世界上第一台Web服务器和Web浏览器

HTTP于1990年问世，但没有作为正式的标准被建立，被称为HTTP/0.9。HTTP正式作为标准被公布是在1996年五月，被命名为HTTP/1.0，该协议标准至今仍被广泛用于服务器端。1997年一月公布的HTTP/1.1是目前主流的HTTP协议版本，当初的标准是RFC0，之后的修订版RFC2616就是当前的最新版。

当年HTTP协议主要是为了解决文本传输的难题，但现在已经超出了Web框架的局限

通常使用的网络是在**TCP/IP**协议族的基础上运作的，HTTP是它内部的一个子集

计算机与网络设备要互相通信就必须基于相同的方法，我们把这个规则称为**协议**，而TCP/IP就是互联网相关各类协议族的总称（也有说法是TCP协议和IP协议，或者是IP协议通信过程中使用到的协议族的统称）

TCP/IP协议很重要的一点就是分层，其按层次分分为**应用层、传输层、网络层、数据链路层**，分层使各个层次内部的设计可以自由改动，简化设计。各层的作用如下：
|层|作用  |
|--|--|
| **应用层** |决定了向用户提供应用服务时通信的活动，HTTP协议也属于该层  |
| **传输层** | 对上层应用层提供处于网络连接中的两台计算机之间的数据储传输，有TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol， 用户数据报协议） |
| **网络层（网络互连层）** |处理网络上流动的数据包，规定通过怎样的路径（传输路线）到达对方计算机传送数据包  |
| **链路层** |处理连接网络的硬件部分，硬件上的范畴均在链路层的作用范围里  |
<br>

在利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信，发送端从应用层向下走，接收端从链路层向上走

发送端在层与层之间传输数据时，每经过一层必定会打上该层所属的首部信息，而接收端则在层与层传输时消去对应的首部
|XX层->XX层| 首部|
|--|--|
| **应用层->传输层** | TCP首部 |
| **传输层->网络层** | IP数据包（IP首部） |
|  **网络层->链路层** | 网络架构（以太网首部） |
这种把数据信息像快递一样层层包装起来的做法叫做封装

TCP/IP协议中与HTTP协议密不可分的有三个协议：

1. **IP协议**
IP（Internet Protocol）协议负责传输，属于网络层，几乎所有使用网络的系统都会用到这个协议。IP 协议的作用是把各种数据包传送给对方。要保证确实传送到对方那里要满足各种条件，最重要的是IP 地址和 MAC地址（Media Access Control Address）<br><br>IP 地址（可以更改）指明了节点被分配到的地址， MAC 地址（基本上不会更改）是指网卡所属的固定地址。<br><br>IP间的通信依赖MAC地址，因为通信通常是要经过多台计算机和网络设备中转，中转时就要利用下一个设备的MAc地址来搜索，这时会采用ARP协议（Address Resolution Protocol，是一种用以解析地址的协议， 根据通信方的 IP 地址就可以反查出对应的 MAC 地址）<br><br>在到达通信目标前，中转计算机和路由器只能获得很粗略的传输路线，这种机制成为路由（routing），无论哪台计算机、网络设备都无法全面掌握互联网的细节
2. **TCP协议**
TCP协议用于确保可靠性，属于传输层，提供可靠的字节流服务<br><br>字节流服务指的是为了方便传输将大块数据分割成以报文段为单位的数据包进行管理。TCP协议为了更容易传送大数据才将数据分割，而且能够确认数据最终是否送达到对方<br><br>为了准确送达，TCP协议采用了三次握手策略，在用TCP协议将数据包送出去后，TCP一定会向对方确认是否成功送达，握手过程中使用TCP的标志（flag）——**SYN**（synchronize）和**ACK**（acknowledgement）<br><br>首先，发送端会发送带SYN标志的数据包给对方，接收端收到后，回传一个带有SYN/ACK标志的数据包表示确认，此时发送端会回传一个带ACK标志的数据包，代表“握手”的结束。如果握手过程突然中断，TCP协议会再以相同的顺序发送数据包。<br><br>（除了上述三次握手， TCP 协议还有其他各种手段来保证通信的可靠性）
3. **DNS协议**
DNS（Domain Name System）协议负责域名解析，属于应用层，提供域名到IP地址间的解析服务<br><br>计算机可以被赋予IP地址、主机名、域名，用户通常使用主机名和域名来访问对方的计算机（因为IP地址是一组纯数字），但是计算机比起处理名称更擅长处理一长串数字，由此，DNS服务诞生了，它提供提供域名查找IP地址，或通过IP地址逆向搜索域名的服务<br><br>发送端想访问一个域名，DNS协议会查找到这个域名对应的IP地址，然后发送端会向这个IP地址发送访问请求

如果要把通信过程中各个协议的作用表述出来，大概就像这样：
发送端想访问一个域名
**DNS协议**会查找到这个域名对应的IP地址。
**HTTP协议**会生成针对目标Web服务器的HTTP请求报文。
**TCP协议**将请求报文分割成多段，按序号分层多个报文段然后将每个报文段可靠地传给对方。
**IP**协议搜索对方的地址，一边中转一边传输。
接收端的**TCP协议**按序号重组报文段。
接收端的**HTTP协议**处理对Web服务器请求的内容。
请求的处理内容同样利用TCP/IP通信协议进行回传

与 URI（统一资源标识符）相比，我们更熟悉 URL（Uniform Resource Locator，统一资源定位符）。URL正是使用 Web 浏览器等访问 Web 页面时需要输入的网页地址。

URI 是 Uniform Resource Identifier 的缩写
**Uniform：**规定统一的格式，方便处理多种不同类型的资源，不需要根据上下文环境来识别资源指定的访问方式，加入新的协议方案也更容易
**Resource：**资源的定义是“可标识的任何东西”。资源不仅可以是单一的， 也可以是多数的集合体
**Identifier：**表示可标识的对象。 也称为标识符

URI 就是由某个协议方案表示的资源的定位标识符，协议方案是指访问资源所使用的协议类型名称，比如采用HTTP协议时，协议方案就是http

URI 用字符串标识某一互联网资源，而 URL表示资源的地点（互联网上所处的位置） 。可见 URL是 URI 的子集

表示指定的URI，可以使用**绝对URI、绝对URL、相对URL**，相对URL指的是从浏览器中基本URI处指定的URL，如 /image/logo.gif

**绝对URI**组成如下：
|名称|描述  |
|--|--|
| **协议方案名** |使用http:或 https:等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）|
|**登录信息**  | （可选），指定用户名和密码作为从服务器端获取资源时必要的登录信息 |
| **服务器地址** | 使用绝对URI必须指定待访问的服务器地址。地址可以是类似hackr.jp这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名，还可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的IPv6地址名 |
| **服务器端口号** | （可选）指定服务器连接的网络端口号。若用户省略则自动使用默认端口号 |
| **带层次的文件路径** | 指定服务器上的文件路径来定位特指的资源 |
|**查询字符串**  | （可选）针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数 |
| **片段标识符组成** |（可选）使用片段标识符通常可标记出已获取资源中的子资源  |
<br>

有一些用来制定 HTTP 协议技术标准的文档,它们被称为RFC（Request for Comments, 征求修正意见书）,不遵照 RFC 标准实现就无法进行 HTTP 协议通信

* **
* ##第二章 简单的HTTP协议

应用HTTP协议时，一端担任客户端角色，一端担任服务器端角色，请求访问资源的是客户端，提供资源响应的是服务器端，角色有可能互换，但HTTP协议能明确区分哪个是客户端哪个是服务器端

HTTP协议规定请求从客户端发出，服务器端响应请求并返回

这个是从客户端发出的请求报文的内容：
```
GET/index.htm HTTP/1.1
Host:hackr.jp
```
开头的```GET```表示请求访问服务器的类型，称为方法
字符串```/index.htm```指明了请求访问的资源对象，也叫做请求URI
最后的HTTP/1.1是HTTP的版本号
请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的

收到请求的服务器会将请求内容的处理结果以响应的形式返回
```
HTTP/1.1 200 OK
Date: Tue, 10 Jul 2012 06:50:15 GMT Content-Length: 362
Content-Type: text/html
<html>
……
```
开头的```HTTP/1.1```表示服务器对应的HTTP版本
```200 OK```表示请求处理结果的状态码和原因短语。
下一行显示了创建响应的日期时间，是首部字段内的一个属性
空一行
后面是资源实体的主体

响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码） 、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成

HTTP是无状态协议，意味着它不保存状态，在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。这个是为了更快地处理大量事务，确保协议的可伸缩性

但随着发展，有些情况网站需要保存用户的状态，于是引入了Cookie技术，这样就可以管理状态了

由于URI的存在，使HTTP协议能定位互联网上的资源从而进行访问

当客户端请求访问资源而发送请求时，URI 需要将作为请求报文中的请求 URI 包含在内。如果不是访问特定资源而是对服务器本身发起请求，可以用一个 * 来代替请求 URI，如：
```
OPTIONS * HTTP/1.1
```
<br>

方法的作用在于可以指定请求的资源按期望产生某种行为，HTTP/1.1中可使用的方法（method）：
1. **GET：获取资源**
GET用来<u>请求访问已被URI识别的资源</u>。指定的资源经服务器端解析后返回响应内容
2. **POST：传输实体主体**
虽然GET方法也可以传输实体的主体，但一般不用GET方法而是使用POST方法，虽然相似，<u>但POST方法的主要目的斌不是回去响应的主体内容</u>
3. **PUT：传输文件**
PUT方法用来传输文件，要求<u>在请求的报文的主体中包含文件内容，然后保存到请求URI指定的位置</u>。但是HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，一般的Web网站不使用该方法。若配合 Web 应用程序的验证机制，或架构设计采用REST（REpresentational State Transfer，表征状态转移）标准的同类Web 网站，就可能会开放使用 PUT 方法。
4. **HEAD：获取报文首部**
该方法和GET方法一样，只是<u>不返回报文主体部分</u>，用来确认URI的有效性和资源更新的日期时间等
5. **DELETE：删除文件**
是和PUT相反的方法，按请求URI删除指定的资源。但它也和PUT一样没有验证机制，一般Web网站不使用
6. **OPTIONS：询问支持的方法**
用来查询针对请求URI指定的资源支持的方法
7. **TRACE：追踪路径**
该方法是让Web服务器将之前的请求通信环回给客户端的方法<br><br>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。<br><br>客户端用TRACE方法可以查询发出去的请求是怎么样被加工修改的，确认连接过程中发生的一系列操作<br><br>但是TRACE方法本来就不常用，还容易引发XST（Corss-Site Tracing，跨站追踪）攻击
8. **CONNECT：要求用隧道协议连接代理**
该方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security， 传输层安全）协议把通信内容加密后经网络隧道传输

向请求URI指定的资源发送请求报文时，采用称为方法的命令

除了以上方法，HTTP/1.0还有LINK（建立和资源之间的联系）和UNLINK（断开连接关系）方法，但已被HTTP/1.1废弃

在HTTP的初始版本中，每进行一次HTTP通信都要断开一次TCP连接，每次请求都会造成无谓的TCP连接建立和断开，增加通信量的开销

为了解决这个问题，HTTP/1.1和一部分的HTTP/1.0推出了**持久连接**的方法，只要任意一端没有明确提出断开连接就保持TCP连接状态。这种方法减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。在HTTP/1.1中，所有连接默认都是持久连接

持久连接使**管线化**成为可能，<u>不需要等待上一个请求得到响应就可以之间发送下一个请求</u>,速度更快

在上面的笔记中有提到Cookie技术的引入使Web可以进行状态的管理

**Cookie技术**通过在请求和响应报文中写入Cookie信息来控制客户端的状态。如果客户端的请求报文中没有Cookie的相关信息，服务器端发送的响应报文中会有一个叫Set-Cookie的首部字段信息通知客户端保存Cookie。客户端以后的请求中会自动在请求报文中加入Cookie值后发送。服务器端在发现客户端发来的Cookie后回去检查时哪个客户端发来的请求，对比服务器上的记录，得到之前的状态信息

 * **
 * ## 第三章 HTTP报文内的HTTP信息
 
用于HTTP协议交互的信息被称为HTTP报文，请求端的叫**请求报文**，响应端的叫**响应报文**。HTTP报文本身是由多行数据（CR+LF作换行符）数据构成的字符串文本

HTTP报文大致分为报文首部和报文主体，由空行划分，并不一定要有报文主体

请求报文和响应报文首部的结构：
|请求报文| 响应报文 |
|--|--|
|请求行  | 状态行 |
| 请求首部字段 | 响应首部字段 |
| 通用首部字段 | 通用首部字段 |
| 实体首部字段 | 实体首部字段 |
| 其他 | 其他 |
<br>

**请求行**
包含请求的方法、请求URI和HTTP版本
**状态行**
包含表明响应结果的状态码，原因短语和HTTP版本
**首部字段**
一般有四种首部，分别是**通用首部、请求首部、响应首部和实体首部**（可能还有Cookie等）

通过在传输时编码，能有效处理大量访问请求。编码操作需要计算机完成，会消耗更多CPU资源

**报文**是HTTP通信的基本单位，由8位组字节流组成，通过HTTP通信传输
**实体**是作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成

HTTP 报文的主体用于传输请求或响应的实体主体，通常报文主体等于实体主体，但当传输中进行编码操作时实体主体内容发生变化，于是产生了差异

HTTP协议中有一种被称为**内容编码**的功能，内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩，内容编码后的实体由客户端接收并负责解码

常用的内容编码有以下几种：
1. gzip（GNU zip）
2. compress（UNIX 系统的标准压缩）
3. deflate（zlib） 
4. identity（不进行编码）

如果请求段编码实体资源尚未全部传输完成，浏览器无法显示请求页面，所以在传输大容量数据时，通过把数据分割成多块**分割物（chunk）**，能够让浏览器逐步显示页面，这种功能称为**分块传输编码**

每一块分割块都会用十六进制来标记大小，实体主体的最后一块会使用“0（CR+LF）”来标记，使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到解码前的实体主体

HTTP 协议中采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用

多部分对象集合包含的对象如下：
1. **multipart/form-data**
在Web表单文件上传时使用
2. **multipart/byteranges**
状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用

在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上Content-type

boundary字符串用来划分多部分对象集合指明的各类实体。在其指定的各个实体的起始行前插入“--”标记，在多部分对象集合对应的字符串的最后插入“--”标记作为结束

如果下载时网络中断，那么就不得不再次从头下载，这个问题想要得到解决需要指定下载的实体范围。指定范围发送的请求叫做**范围请求**

执行范围请求时，会用到首部字段Range来指定资源的byte范围

```Range：bytes=5000-10000```就是指定了5000~10000字节，也可以有```Range：bytes=5000-10000，12000-15000```的双重范围

针对范围请求，响应会返回状态码为206 Partial Content的响应报文。如果是多重范围，那么响应会在首部字段ContentType标明multipart/byteranges后返回响应报文

（如果服务器端没办法响应范围请求，那么就会返回状态码200 OK和完整的实体内容）

**内容协商**机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源，包含在请求报文中的某 些首部字段会作为判断是否是最合适资源的基准，如：**Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language**

内容协商技术有三种类型：
|类型| 描述 |
|--|--|
| **服务器驱动协商** | 由服务器端进行内容协商，以请求的首部字段进行参考，但对用户来说不一定是最合适的 |
| **客户端驱动协商** | 由客户端进行内容协商，就类似于手动选择浏览器语言。存在需要第二次请求而获得最好表现形式的缺点。第二次请求只有当缓存被使用时才是有效率的 |
| **透明协商** | 服务器驱动和客户端驱动的结合体，两端各自进行内容协商。结合了服务器和客户端的协商能力，能够更好地满足不同用户的需求。通过缓存利用代理驱动协商的信息，减少了服务器的负担，提高了响应速度。提供最适合用户的资源，提升用户体验‌ |
* **
* ## 第四章 返回结果的HTTP状态码
HTTP状态码负责表示客户端HTTP请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。用户根据状态码，可以知道服务器端是正常处理了请求，还是出现了错误

|  | 类别 | 原因短语 | 
|--|--|--|
| **1XX** | Informational（信息性） | 接收的请求正在处理 |
| **2XX** | Success（成功状态码） | 请求正常处理完毕 |
| **3XX** | Redirection（重定向状态码） | 需要进行附加操作以完成请求 |
| **4XX** | Client Error（客户端错误状态码） | 服务器无法处理请求 |
| **5XX** | Server Error（服务器错误状态码） | 服务器处理请求出错 |

经常使用的状态码共有14种：

* **2XX类**
   1. **200 OK**：表示客户端发来的请求在服务器端被正常处理了
   2. **204 No Content**：服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分
   3. **206 Partial Content**：表示客户端进行了范围请求，服务器成功执行了这部分的GET请求，响应报文中包含由 Content-Range 指定范围的实体内容
   
* **3XX类**
    4. **301 Moved Permanently**：永久性重定向，表示请求的资源已经被分配了新的URI，以后应该使用资源现在所指的URI
    5. **302 Found**：临时性重定向，该状态码表示请求的资源已经被分配了新的URI，希望用户（本次）能使用新的URi访问。虽然与301 Moved Permanently类似，但该状态码代表的资源不是永久移动，而是临时性的，未来URI可能还会改变
    6. **303 See Other**：表示由于请求对应的资源 存在另一个URI，应该使用GET方法定向获取请求的资源。与302 Found相似，但明确要求客户端用GET方法获取资源  
 
 
    当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。<br><br>（301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做）（草）
    7. **304 Not Modified**：表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。虽然该状态码为3XX，但和重定向没有关系
    8. **307 Temporary Redirect**：临时重定向，与302 Found有相同含义，尽管302标准禁止POST变换成GET，但大家都不遵守。307不会从POST变GET
* **4XX类**
    9. **400 Bad Request**：表示请求报文中存在语法错误，浏览器会像200 OK一样对该状态码
    10. **401 Unauthorized**：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息，若之前已经进行过一次请求，则表示用户认证失败<br><br>返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用来质询（challenge）用户信息，浏览器第一次接收到401响应的时候会弹出认证用对话窗口 
    11. **403 Forbidden**对请求资源的访问被服务器拒绝，服务器端没有必要给出拒绝的理由，但可以在实体的主体部分对原因进行描述让用户明白
    12. **404 Not Found**：服务器上无法找到请求的资源，也可以在服务器端拒绝请求不想说明理由时使用
 * **5XX类**
    13. **500 Internal Server Error**：服务器端在执行请求时发生了错误
    14. **503 Service Unavailable**：服务器正在进行停机维护或暂时处于超负载状态，无法处理请求。如果事先得知解除以上状况需要的时间，最好写入RetryAfter首部字段再返回给客户端
 <br>
 
（不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种情况也经常遇到)
 * **
* ## 第五章 与HTTP协作的Web服务器
一台Web服务器可以搭建多个独立域名的Web网站，也可以作为通信路上的中转服务器提示传输效率

HTTP/1.1规范允许一台HTTP服务器搭建多个Web站点，即使物理层面只有一台服务器，但只要使用了**虚拟主机（又称虚拟服务器）**的功能就可以假想已具有多台服务器

当客户端使用HTTP协议访问服务器时，经常会采用主机名和域名，这些域名通过DNS服务映射到IP地址之后访问目标网站，所以当一台服务器内托管了多个域名，收到请求时就要搞清楚究竟要访问哪个域名（这是因为它们的IP地址会相同）。这时就必须在发送HTTP请求时在Host首部内完整指定主机名或域名的URI

在HTTP通信时，除了客户端和服务器还有一些用于通信数据转发的应用程序，如**代理、网关、隧道**。这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端

1. **代理：**
代理是一种有转发功能的应用程序，扮演了位于服务器和客户端“中间人”的角色，接收客户端的请求转发给服务器，也接收服务器的响应转发给客户端
<br>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI。持有资源实体的服务器称为源服务器，从源服务器返回的响应经过代理服务器后再传给客户端
<br>每次通过代理服务器转发时会追加写入**Via**首部信息
<br>使用代理服务器可以利用缓存技术减少网络宽带的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的
<br>代理有多种使用方法，按两种基准分：**一种是是否使用缓存，另一种是是否会修改报文**<br>
缓存代理：代理转发响应时会预先将资源的副本（缓存）保存在代理服务器上。当代理再次收到对相同资源的请求时，就可以不从服务器获取资源，而是将之前缓存的资源作为响应返回
<br>透明代理：转发或响应时不对报文做任何加工的代理。反之对报文内容进行加工的称为非透明代理
2. **网关：**
网格是转发其他服务器通信数据的服务器，接收从客户端发来的请求时就像自己拥有资源的服务器用于对请求进行处理
<br>利用网关可以由HTTP请求转化为其他协议通信。网关的工作机制和代理相似，但网关能使通信线路上的服务器提供非HTTP协议服务
<br>利用网关能提高通信的安全性，因为可以在客户端和网关之间的通信线路上加密确保连接安全
3. **隧道：**
隧道是在相隔很远的客户端与服务器进行中转，并保持双方通信连接的应用程序
<br>隧道可以按要求建立起一条与其他服务器的通信道路，使用SSL等加密手段进行通信，目的是确保客户端能和服务器安全通信
<br>隧道本身不会去解析HTTP请求。隧道会在通信双方断开连接时结束

**缓存**指的是代理服务器或客户端本地磁盘内保存的资源副本，利用缓存可以减少对源服务器的访问，节省通信流量和通信时间

缓存服务器是代理服务器的一种，并归类在缓存代理类型中。换句话说，当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。这样源服务器就不用多次处理相同的请求了

缓存是有有效期限的，当源服务器的资源更新时，如果缓存没有更新，那么响应的内容就是之前的旧资源。即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源有效性，如果判断缓存失效，就会再次从服务器上获取资源

缓存不仅可以存在缓存服务器内，也可以存在客户端浏览器里面。浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。如果失效就会和缓存服务器一样向源服务器请求新资源

* **
* ## 第六章 HTTP首部
HTTP协议的请求和响应报文中一定包含HTTP首部，即使平时使用Web的时候感受不到它们

首部内容为客户端和服务器分别处理请求和响应提供所需要的信息

HTTP首部字段是构成HTTP报文的要素之一，无论是请求还是响应都会使用首部字段，它起到传递额外重要信息的作用。使用首部字段可以给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容

HTTP首部字段由**首部字段名**和**字段值**组成，中间由```:```分隔，字段值对应的单个HTTP首部字段可以有多个值，如```Keep-Alive：timeout=15，max=100```

如果首部字段重复，根据浏览器内部处理逻辑的不同可能会有不同的结果，有的处理第一次，有的处理最后一次

HTTP首部字段根据实际用途被分为四种类型：
|类型| 描述 |
|--|--|
| **通用首部字段** | 请求报文和响应报文都会使用的首部 |
| **请求首部字段** |从客户端向服务器端发送请求报文时使用的首部，补充了请求附加内容、客户端信息、响应内容相关优先级等 |
|**响应首部字段** | 从服务器端向客户端返回响应报文时使用的首部，补充了响应的附加内容，也会要求客户端附加额外的内容信息 |
|**实体首部字段**  | 针对请求报文和响应报文的实体部分使用的首部，补充了资源内容更新时间等与实体有关的信息|

<br>

| 通用首部字段 | 描述 |
|--|--|
| **Cache-Control** | 控制缓存的行为 |
| **Connection** | 逐跳首部、 连接的管理 |
| **Date** | 创建报文的日期时间 |
| **Pragma** | 报文指令 |
| **Trailer** | 报文末端的首部一览 |
| **Transfer-Encoding** | 指定报文主体的传输编码方式 |
| **Upgrade** | 升级为其他协议 |
| **Via** | 代理服务器的相关信息 |
| **Warning** | 错误通知 |
<br>

| 请求首部字段 | 描述 |
|--|--|
| **Accept** | 用户代理可处理的媒体类型 |
| **Accept-Charset** | 优先的字符集 |
| **Accept-Encoding** |优先的内容编码 |
| **Accept-Language** | 优先的语言（自然语言） |
| **Authorization** | Web认证信息 |
| **Expect** | 期待服务器的特定行为 |
| **From** | 用户的电子邮箱地址 |
| **Host** | 请求资源所在服务器 |
| **If-Match** |比较实体标记（ETag）|
| **If-Modified-Since** | 比较资源的更新时间 |
| **If-None-Match** | 比较实体标记（与 If-Match 相反） |
| **If-Range** | 资源未更新时发送实体 Byte 的范围请求 |
| **If-Unmodified-Since** | 比较资源的更新时间（与If-Modified-Since相反） |
| **Max-Forwards** | 最大传输逐跳数 |
| **Proxy-Authorization** | 代理服务器要求客户端的认证信息 |
| **Range** | 实体的字节范围请求 |
| **Referer** | 对请求中 URI 的原始获取方|
| **TE** | 传输编码的优先级|
| **User-Agent** | HTTP 客户端程序的信息|
<br>

|响应首部字段名|描述|
|--|--|
|**Accept-Ranges**|是否接受字节范围请求|
|**Age**|推算资源创建经过时间|
|**ETag**|资源的匹配信息|
|**Location**|令客户端重定向至指定URI|
|**Proxy-Authenticate**|代理服务器对客户端的认证信息|
|**Retry-After**|对再次发起请求的时机要求|
|**ServerHTTP**|服务器的安装信息|
|**Vary**|代理服务器缓存的管理信息|
|**WWW-Authenticate**|服务器对客户端的认证信息|
<br>

|实体首部字段名|说明|
|--|--|
|**Allow**|资源可支持的HTTP方法|
|**Content-Encoding**|实体主体适用的编码方式|
|**Content-Language**|实体主体的自然语言|
|**Content-Length**|实体主体的大小（单位： 字节）|
|**Content-Location**|替代对应资源的URI|
|**Content-MD5**|实体主体的报文摘要|
|**Content-Range**|实体主体的位置范围|
|**Content-Type**|实体主体的媒体类型|
|**Expires**|实体主体过期的日期时间|
|**Last-Modified**|资源的最后修改日期时间|
<br>

还有一些非HTTP/1.1首部字段，如Cookie、Set-Cookie、Content-Disposition等等，这些非正式的首部字段统一归纳在RFC4229 HTTP Header Field Registrations中

HTTP首部字段将定义成缓存代理和非缓存代理的行为，分成两种类型：
**端到端首部：** 分在此类别的首部会转发给请求/响应对应的最终目标，且必须保存在缓存生成的响应中，另外规定它必须被转发
**逐跳首部：** 分在此类别的首部只对单词转发有效，会因提供缓存或代理而不再转发，在HTTP/1.1和之后的版本中，要使用这类首部需要提供Connection首部字段

HTTP/1.1中的逐条首部有**Connection、Keep-Alive、Proxy-Authenticate、Proxy-Authorization、Trailer、TE、Transfer-Encoding、Upgrade**。除了这些，其他都是端到端首部
* **
* ### 通用首部字段
 **Cache-Control：**
通过指定首部字段**Cache-Control**的指令，就能操作缓存的工作机制，指令的参数是可选的，多个指令通过","分隔

|缓存请求指令| 参数 |说明|
|--|--|--|--|
|**no-cache** |无 |强制向源服务器再次验证|
|**no-store** |无| 不缓存请求或响应的任何内容|
|**max-age = [ 秒]**| 必需| 响应的最大Age值|
|**max-stale( = [ 秒])**| 可省略| 接收已过期的响应|
|**min-fresh = [ 秒]**|必需|期望在指定时间内的响应仍有效|
|**no-transform**|无|代理不可更改媒体类型|
|**only-if-cached**|无|从缓存获取资源|
|**cache-extension**|-|新指令标记（token）|
<br>

|缓存响应指令|参数|说明|
|--|--|--|
|**public**|无|可向任意方提供响应的缓存|
|**private**|可省略|仅向特定用户返回响应|
|**no-cache**|可省略|缓存前必须先确认其有效性|
|**no-store**|无|不缓存请求或响应的任何内容|
|**no-transform**|无|代理不可更改媒体类型|
|**must-revalidate**|无|可缓存但必须再向源服务器进行确认|
|**proxy-revalidate**|无|要求中间缓存服务器对缓存的响应有效性再进行确认|
|**max-age = [ 秒]**|必需|响应的最大Age值|
|**s-maxage = [ 秒]**|必需|公共缓存服务器响应的最大Age值|
|**cache-extension**|-|新指令标记（token)|
<br>

当指定使用```public```指令时，表明其他用户也可以利用缓存。与其相反，```private```指令指定后响应只以特定的用户作为对象，对于其他用户发送过来的请求，代理服务器则不会返回缓存

使用```no-cache```指令的目的是为了防止从缓存中返回过期的资源。如果请求中包含了```no-cache```，那么就表示客户端不接受缓存过的响应，中间的缓存服务器必须把请求转发给源服务器

如果是服务器的响应中包含```no-cache```，那么缓存服务器不能对该资源进行缓存

由服务器返回的响应中， 若报文首部字段 ```Cache-Control ```中对```no-cache```字段名具体指定参数值， 那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。**只能在响应指令中指定该参数**

当使用```no-store```指令时，暗示请求或响应中包含机密信息，所以该指令规定缓存不能在本地存储请求或响应的任一部分（```no-store```才是真正的不缓存，```no-cache```代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源）

**s-maxage指令：** 其功能和```max-age```相同，它们的不同点是```s-maxage```指令只适用于供多位用户使用的公共缓存服务器（指代理，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用

使用```s-maxage```指令后，则直接忽略对Expires首部字段及```max-age```指令的处理

**max-age指令：** 当客户端发送的请求中包含```max-age```指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。如果其值为0，就要把请求转发给源服务器

服务器端的响应包含```max-age```指令时，缓存服务器将不对资源的有效性再作确认，其值代表资源保存为缓存的最长时间

HTTP/1.1版本的缓存服务器会优先处理```max-age```而忽略掉Expires首部字段，HTTP/1.0却刚好相反

**min-fresh指令：** 要求缓存服务器返回至少还未过指定时间的缓存资源

**max-stale指令：** 可以指示缓存资源即使过期也照样接收，未指定参数的话，那么无论经过多久，客户端都会接收响应。反之只要仍处于 max-stale指定的时间内，仍旧会被客户端接收

**only-if-cached指令：** 使用该指令代表客户端仅在缓存服务器缓存目标资源的情况下才要求其返回。若发生请求缓存服务器的本地缓存无响应，则返回状态码504 Gateway Timeout

**must-revalidate指令：** 使用该指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。如果代理无法联通源服务器获取有效资源的话就必须返回504状态码。

使用该指令会忽略请求中的```max-stale```指令

**proxy-revalidate指令：** 该指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性

**no-transform指令：** 该指令规定无论在请求还是响应中，缓存都不能更改实体主体的媒体类型

通过cache-extension标记（token），可以扩展Cache-Control首部字段内的指令
```Cache-Control: private, community="UCI"```
Cache-Control 首部字段本身没有 community 这个指令。借助extension tokens 实现了该指令的添加。如果缓存服务器不能理解```community```这个新指令就会直接忽略

**Connection**首部具有两个作用：

1. 控制不再转发给代理的首部字段
```Connection: 不再转发的首部字段名```
2. 管理持久连接
HTTP/1.1版本的默认连接都是持久连接，当服务器端明确想断开连接时，会将其值改为Close

在之前的HTTP版本中默认是非持久连接，如果想要在旧版HTTP协议上维持持续连接，需要将其值改为Keep-Alive

**Date**表面创建HTTP报文的日期和时间
HTTP/1.1用的格式为```Date: Tue, 03 Jul 2012 04:40:59 GMT```

**Pragma**是HTTP/1.1之前版本的历史遗留字段，仅作为HTTP/1.0的向后兼容而定义

规范定义的形式唯一，如下所示：
```Pragma: no-cache```
虽然该首部字段属于通用首部字段，但只用在客户端发送的请求中，客户端会要求所有的中间服务器不返回缓存的资源

但是可能有点中间服务器版本不是HTTP/1.1，所以发送的请求会有下面两个首部字段：
```
Cache-Control: no-cache 
Pragma: no-cache
```
<br>

**Trailer**会事先说明在报文主体后记录了哪些首部字段

**Transfer-Encoding**规定了传输报文主体时采用的编码方式

**Upgrade**用于检测HTTP协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议

因为Upgrade首部字段产生作用的对象仅限于客户端和邻接服务器之间，所以使用首部字段Upgrade时，还需要额外指定```Connection:Upgrade```

**Via**是为了追踪客户端和服务器之间的请求和响应报文的传输路径。报文经过代理或网关时，会先在首部字段Via中附加该服务器的信息，然后再进行转发。它不仅可以追踪报文的转发，还可以避免请求回环的发生

**Warning**是从HTTP/1.0的响应首部（Retry-After）演变过来的，其格式如下：
```Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])```日期时间可以省略

HTTP/1.1定义了七种警告，警告码具有拓展性，可能之后追加新的警告码

|警告码|警告内容|说明|
|--|--|--|
|110|Response is stale（响应已过期）|代理返回已过期的资源|
|111|Revalidation failed（再验证失败）|代理再验证资源有效性时失败（服务器无法到达等原因）|
|112|Disconnection operation（断开连接操作）|代理与互联网连接被故意切断|
|113|Heuristic expiration（试探性过期）|响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）|
|199|Miscellaneous warning（杂项警告）|任意的警告内容|
|214|Transformation applied（使用了转换）|代理对内容编码或媒体类型等执行了某些处理时|
|299|Miscellaneous persistent warning（持久杂项警告）|任意的警告内容|
<br>

* **
* ### 请求首部字段

**Accept**首部字段可以通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可以使用type/subtype的形式指定多个媒体类型
|媒体类型| 格式 |
|--|--|
| 文本文件 | **text/html,text/plain,text/css... application/xhtml+xml,application/xml...** |
| 图片文件 | **image/jpeg,image/gif,image/png...** |
|视频文件|**video/mpeg,video/quicktime...** |
| 应用程序使用的二进制文件 | **application/octet-stream,application/zip...** |
<br>

如果想给显示的媒体类型加优先级，就用q=来额外表示权重值，用分号（；）进行分隔，q的范围是0~1，可以精确到小数点后三位

**Accept-Charset**首部字段可以用来通知服务器用户代理支持的字符集和字符集相对优先顺序，和Accept一样用q表示相对优先集。该首部字段应用于内容协商机制的服务器驱动协商

**Accept-Encoding**首部字段告知服务器用户代理支持的内容编码及内容编码的优先级顺序，如：**gzip**（由文件压缩程序gzip（GNU zip）生成的编码格式，采用Lempel-Ziv算法和32位循环冗余校验）、**compress**（由UNIX文件压缩程序compress生成的编码格式，采用LempelZiv-Welch算法（LZW））、**deflate**（组合使用zlib格式及由deflate压缩算法生成的编码格式）、**identity**（不执行压缩或不会变化的默认编码格式）

**Accept-Language**首部字段用于告知服务器用户代理能够处理的自然语言集，和自然语言集的相对优先级，一样用权重值q表示。格式如：```Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3```

**Authorization**首部字段是用来告知服务器用户代理的认证信息。通常想要通过服务器认证的用户代理会在接收到返回的401状态码响应后，把首部字段Authorization加入请求中

**Expect**首部字段用来告知服务器期望出现的某种特定行为。如果服务器无法理解客户端的期望做出回应而发生错误时，会返回状态码417 Expectation Failed

客户端可以利用该首部字段， 写明所期望的扩展。虽然 HTTP/1.1 规范只定义了100-continue（状态码100 Continue之意）。等待状态码100响应的客户端在发生请求时，需要指定Expect:100- continue

**From**首部字段用来告知服务器使用用户代理的用户电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式

**Host**首部字段用于区分运行在同一个IP上的虚拟主机。Host首部字段是HTTP/1.1规范内唯一一个必须被包含在请求内的首部字段。其格式如：```Host:www.hackr.jp```

**If-Match**首部字段，形如If-XXX这样形式的请求首部字段都可以称为条件请求，只有服务器判断指定条件为真时才会执行请求

只有当If-Match的字段值跟ETag值匹配一致时，服务器才会接受请求，否则返回状态码412 Precondition Failed的响应

（还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略ETag的值，只要资源存在就处理请求）

**If-Modified-Since：** 如果在其指定的日期时间之后资源发生了更新，服务器会接受请求。如果该时间之后资源都没有更新，则返回状态码304 Not Modified的响应

**If-None-Match**首部字段和If-Match作用相反

**If-Range**首部字段属于附带条件之一，它告知服务器若指定的If-Range字符值（Etag值或者时间）和请求资源的一致时，则作为范围请求处理，否则返回全部资源

**If-Unmodified-Since**首部字段的作用和If-Modified的作用相反

**Max-Forwards：** 通过TRACE方法或OPTIONS方法， 发送包含首部字段MaxForwards的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards的值减1后重新赋值。当服务器接收到Max-Forwards值为0的请求时，则不再进行转发，而是直接返回响应

使用该首部字段可以调查传输路径的通信状况

**Proxy-Authorization：** 当收到代理服务器发来的认证质询时，客户端会发送包含该首部字段的请求，告知服务器认证需要的信息。（这个认证行为在客户端和代理之间，客户端和服务器之间的认证用Authorization首部字段）

**Range**首部字段用于只需获取部分资源的范围请求，收到带该首部字段请求的服务器会在处理请求后返回状态码206 Partial Content的响应。如果无法处理该请求，就会返回200 OK并返回全部资源

**Referer**首部字段会告知服务器请求的原始资源的URI。但可能会有安全性问题，可以考虑不发送该首部字段。（顺便它的正确拼写应该是Referrer，但大家都用这个错误的拼写）

**TE**首部字段会告知服务器客户端能够处理响应的传输编码和相对优先级（也是q），和Accept-Encoding功能很香，但是用于传输编码

它除了指定传输编码，还可以指定伴随trailer字段的分块传输编码方式，只需把trailers赋值给字段值

**User-Agent**用于传达浏览器的种类，它会将浏览器和用户代理名称传达给服务器。由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。如果请求经过代理，中间也可能加上代理服务器的名称
* **
* ### 响应首部字段

**Accept-Ranges**首部字段用来告知客户端服务器能否处理范围请求，以指定获取服务器端某个部分的资源。可指定的值有两种：**bytes（可处理范围请求时）**、**none**

**Age**首部字段告知客户端源服务器在多久前创建了响应，单位为秒。如果是缓存服务器创建该响应，那么其值指的是缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段Age

**Etag**首部字段能告知客户端实体标识，是一种可将资源以字符串形式做唯一性标识的方式，服务器会为每份资源分配Etag值

资源更新时Etag值也需要更新，没有生成Etag统一的算法规则，仅仅由服务器分配

Etag值有强弱之分，强Etag值不管实体发生了多么细微的变化都会改变其值。弱Etag值只用于提示资源是否相同，只有资源发生了根本改变产生强烈差异时才会改变Etag值。这时会在字段值最开始时附加```W/```

**Location**首部字段可以将响应接收方引导至某个和请求URI不同的资源，该字段会配合3xx重定向响应。几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问

**Proxy-Authenticate**首部字段会把由代理服务器所要求的认证信息发送给客户端

它与客户端和服务器之间的HTTP访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间进行认证时，首部字段WWW-Authorization有着相同的作用

**Retry-After**首部字段告知客户端应该在多久之后再次发送请求，主要配合503 Service Unavailable或3XX Redirect一起使用

字段值可以是具体的时间日期，也可以是创建响应后的秒数

**Server**首部字段告知客户端当前服务器上安装的HTTP服务器应用程序的信息，不止标出服务器上软件应用名称，还有可能包括版本号和安装时启用的可选项

**Vary：** 当代理服务器收到带有Vary首部字段指定获取资源的请求时，如果使用的Accept-Language字段的值相同，那么就直接从缓存返回响应，否则就要从源服务器获取资源此案作为响应返回

首部字段Vary可对缓存进行控制。从代理服务器接收到源服务器返回包含Vary指定项的响应之后，若再要进行缓存，仅对请求中含有相同Vary指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于Vary指定的首部字段不相同，因此必须要从源服务器重新获取资源

**WWW-Authenticate**首部字段用于HTTP访问认证，告知客户端适用于访问请求URI所指的资源的认证方案和带参数提示的质询，状态码401 Unauthorized响应中一定带有该首部字段
* **
* ### 实体首部字段

**Allow**首部字段用于通知客户端能够支持Request-URI指定资源的所有HTTP方法。当服务器接收到不支持的HTTP方法时会以状态码405 Method Not Allowed作为响应返回，还会把所有支持的HTTP方法写入Allow中返回

**Content-Encoding**首部字段会告知客户端服务器对实体的主体部分选用的内容编码方式（各方式看Accept-Encoding的笔记）

**Content-Language**首部字段会告知客户端实体主体使用的自然语言

**Content-Length**首部字段表明了实体主体部分的大小，单位是字节。对实体部分进行编码传输时，不能使用该首部字段

**Content-Location**首部字段给出报文主体部分相对应的URI。和Location不同，它表示的是报文主体返回资源对应的URI。

对于使用首部字段Accept-Language的服务器驱动型请求，当返回的页面内容和实际请求对象不同时，它会写明URI

**Content-MD5：** 客户端会对接收的报文主体执行相同的MD5算法，然后和该首部字段的字段值相比较，目的在于检查报文主体在传输过程中是否保持完成以及确认传输到达

**Content-Range：** 针对范围请求，返回响应时使用的首部字段Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小

**Content-Type**首部字段说明了实体主体内对象的媒体类型，和首部字段Accept一样，字段值用type/subtype形式赋值。其格式如下：
```Content-Type: text/html; charset=UTF-8```
参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值

**Expires**首部字段会将资源失效日期告诉客户端。缓存服务器在接收到含有该首部字段的响应后会以缓存来应答请求，在其指定的时间之前响应的副本会一直被保存。如果超过了时间，缓存服务器收到请求时会转向源服务器请求资源

源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。如果Cache-Control有max-age指令时，会先处理max-age指令

**Last-Modified**首部字段指明资源最终修改的时间

* **
* ### 为Cookie服务的首部字段

虽然Cookie没有被编入标准化的HTTP/1.1的RFC2616中，但在Web网站有广泛的应用

Cookie的工作机制是用户识别和状态管理，调用Cookie时因为可以校验Cookie的有效期和发送方的域、路径、协议等信息，正规发布的Cookie内的数据不会因为其他Web站点的攻击而泄露

为Cookie服务的首部字段有**Set-Cookie**和**Cookie**

**Set-Cookie**是响应首部字段，当服务器准备开始管理客户端的状态时会事先告知各种信息。其属性有：
|属性|说明|
|--|--|
|**NAME=VALUE**|赋予Cookie的名称和其值（必需项）|
|**expires=DATE**|Cookie的有效期（若不明确指定则默认为浏览器关闭前为止）|
|**path=PATH**|将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）|
|**domain=域名**|作为Cookie适用对象的域名（若不指定则默认为创建Cookie的服务器的域名）|
|**Secure**|仅在HTTPS安全通信时才会发送 Cookie|
|**HttpOnly**|加以限制，使Cookie不能被JavaScript脚本访问|

**expires属性**指定浏览器可发送Cookie的有效期，如果省略就代表有效期仅限于维持浏览器会话的时间段内。一旦Cookie通过服务器发送至客户端，服务器端就不存在可显式删除Cookie的方法，但可以覆盖已过期的Cookie实现对客户端Cookie的实质删除

**path属性**限制指定Cookie的发送范围的文件目录。但有办法避开这个限制，不能对安全性抱怨期待

**domain属性：** 通过Cookie的domain属性指定的域名可做到与结尾匹配一致（指定example.com后，除example.com以外，www.example.com或www2.example.com等都可以发送 Cookie）。所有除了针对具体指定的多个域名发送Cookie之外，不指定domain属性更安全

**secure属性**用于限制 Web 页面仅在HTTPS安全连接时，才可以发送Cookie。如```Set-Cookie: name=value; secure```就是只有在https://www.example.com/（HTTPS）安全连接的情况下才会进行Cookie回收，即使域名相同，http://www.example.com/（HTTP）不会发生回收Cookie的行为

如果省略这个属性那就一律回收了

**HttpOnly属性**是Cookie的扩展功能，主要是防止JavaScript跨站脚本攻击信息窃取Cookie。Web页面内还可以对Cookie读取，但JS里的document。cookie就无法读取内容

**Cookie：** 首部字段Cookie会告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie。接收到多个Cookie时，同样可以以多个Cookie形式发送

* **
* ### 其他首部字段

HTTP的首部字段是可以自行扩展的，所有会出现各种非标准的首部字段，以下是一些常见的首部字段：

1. **X-Frame-Options**
属于HTTP响应首部，控制网站内容在其他Web网站的Frame标签内的显示问题。主要是防止点击劫持攻击<br><br>它有两个可指定的字段值：**DENY（拒绝）**、**SAMEORIGIN（仅同源域名下的页面）**
2. **X-XSS-Protection**
属于HTTP响应首部，是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关<br><br>它有两个可指定的字段值：**0：将 XSS 过滤设置成无效状态**、**1：将 XSS 过滤设置成有效状态**
3. **DNT**
属于HTTP请求首部，是Do Not Track的简称，拒绝被精确广告追踪的一种方法<br><br>它有两个可指定的字段值：**0：同意被追踪**、**1：拒绝被追踪**
4. **P3P**
属于HTTP响应首部，可以使Web网站上的个人隐私变成一种仅供程序可以理解的形式，保护用户隐私<br><br>要进行P3P设定，首先要创建P3P隐私，然后创建P3P隐私对照文件后，保存命名在 /w3c/p3p.xml，最后从P3P隐私中新建Compact policies后，输出到HTTP响应中
* **
* ## 第七章 确保Web安全的HTTPS

HTTP协议中有可能存在信息窃听或身份伪装等安全问题，但也可以得到解决

HTTP的不足点如下：

1. **使用通信明文，内容可能被窃听**
由于HTTP本身不具备加密功能，无法做到对通信整体进行加密。按TCP/IP协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。即使加密了报文，虽然可能让人无法破解报文信息，但报文本身还是会被看到<br><br>窃取相同段上的通信只需要收集互联网上流动的数据包即可，可以利用抓包或嗅探器工具进行收集<br><br>目前研究如何防止窃听的方法中，最为普及的就是加密技术，可以加密的对象有那么几个：
   1. **通信加密**，通过SSL（安全套接层）或TLS（安全层传输协议）的组合使用加密HTTP通信内容。用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP称为HTTPS
   2. **内容加密**，把HTTP协议传输的内容本身加密。在这种情况下，客户端需要对HTTP报文进行加密处理后再发送请求。但要使加密有效需要让客户端和服务器端同时具备加密和解密机制，而且内容仍然有被篡改的风险
2. **不验证通信方的身份，有可能遭遇伪装**
HTTP协议中的请求和响应不会对通信方进行确认。任何人都可以发起请求，服务器也不管对方是谁都会返回一个响应（仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下）。但是不确认通信方会存在各种隐患，如**无法确认目标服务器是否是伪装的服务器；无法确认收到响应是否是伪装的客户端；无法确定正在通信的对方是否具有访问权限；无法确定请求来自哪里，是谁发起的；即使是无意义的请求也会接收（DoS攻击）**<br><br>虽然HTTP协议无法确认通信方，但使用SSL却可以，SSL不仅提供加密处理，还使用了一种名为证书的手段。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是真实存在的，伪造证书从技术角度来说很难做到
3. **无法证明报文的完整性**
完整性是指信息的准确度，如果无法证明完整性也就意味着无法判断信息是否准确<br><br>再请求或响应送出到对方接收这段时间，即使内容遭到篡改也没有办法获悉。再响应或传输的途中遭攻击者拦截并且篡改内容的攻击称为**中间人攻击（Man-in-the-Middle attack，MITM）**<br><br>虽然有使用HTTP协议确定报文完整性的方法，但这种方法并不便捷可靠。最常用的方法是**MD5**和**SHA-1**等散列值校验的方法，还有用来确认文件的数字签名方法<br><br>但这些方法也不是百分百确认结果正确，因为如果方法本身被改写用户也没法意识到，为了解决这些弊端就有必要使用HTTPS

**HTTPS=HTTP+加密+认证+完整性保护**

经常会在Web的登陆页面和购物结算页面等使用HTTPS通信，使用HTTPS通信时不再使用http://而是https://。而且地址栏里会出现一个带锁的标记

HTTPS并非是应用层的一种新协议，只是HTTP接口部分用SSL和TLS协议代替。通常HTTP直接和TCP通信，但是使用HTTPS时，它会先和SSL通信，SSL再和TCP通信。采用SSL后，HTTP就有了HTTPS的加密、证书、完整性保护这些功能

SSL是独立HTTP的协议，可以配合其他协议使用，可以说它是当今世界上应用最广泛的网络安全技术

SSL采用一种叫做**公开密钥加密**的方法

近代的加密方法中加密算法是公开的，但密钥是保密的，这种方式可以保持加密算法的安全性

如果是**共享密钥加密（对称密钥加密）**，那么就会遇到一个很矛盾的问题：你要想接收方能够解密，就得把密钥也一起发送，这也就意味着攻击方也可以获得密钥，那么加密就失去了意义。如果密钥能安全的到接收者手中，那数据本来就可以安全送达，就不需要加密。此外还得设法安全保管密钥

**公开密钥加密**就很好地解决了这个问题。它使用一种非对称的密钥，一把叫做**私有密钥**，一把叫做**公开密钥**。使用该方法进行通信时，发送密文的一方使用对方的公开密钥进行加密，对方收到信息后用私有密钥进行解密，这样就不需要发送解密的私有密钥了

想要根据密文和公开密钥恢复到信息原文是相当困难的，因为当下技术不能做到对一个非常大的整数进行快速的因式分解

HTTPS采用**混合加密机制**，也就是说它采用共享密钥加密和公开密钥加密两者并用的混合加密机制。如果密钥能实现安全交换就有可能考虑仅使用公开密钥加密来通信，但是公开密钥加密处理速度要慢

所以将两者各自的优势结合，在交换密钥时采用公开密钥加密，之后的通信使用共享密钥加密

遗憾的是公开密钥加密还是存在漏洞，就是无法证明公开密钥是否被攻击者替换掉。为了解决这个问题就可以使用数字证书认证机构和其相关机构颁发的公开密钥证书，其业务流程如下：

1. 服务器运营人员向数字证书认证机构提出公开密钥的申请
2. 机构在判明申请者的身份后会对已申请的公开密钥做数字签名
3. 分配这个已签名的公开密钥，将该密钥放入公钥证书后绑定在一起

然后服务器会将这份由数字证书认证机构办法的公钥证书发送给客户端。客户端收到后对证书上的数字签名进行验证，一旦验证提供，客户端便知道**认证服务器的公开密钥的是真实有效的数字证书认证机构**和**服务器的公开密钥是值得信赖的**

此处的公开密钥必须安全转交给客户端，所有多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥

EV SSL证书可以确认对方服务器背后运营的企业是否真实存在。它是基于国际标准的认证指导方针颁发的证书，通过认证的Web网站能获得更高认可度。持有该证书的网站浏览器地址栏处的背景色是绿色的，而且在地址栏的左侧显示了 SSL证书中记录的组织名称以及颁发证书的认证机构的名称

HTTPS中还可以使用客户端证书，作用和服务器差不多，用于服务器确认通信的对方是预料之内的客户端。但这个也不能用来证明用户本人的真实有效性

**认证机构的信誉十分重要**，如果数字签名被伪造那么证书就会被判定为正当的，会造成利益损失

如果使用OpenSSL这套开源程序，每个人都可以构建属于自己的认证机构，给自己的服务器颁发证书，在互联网上不可做为证书使用，只能自己玩玩

HTTPS的通信步骤如下：

1. 客户端发送Client Hello报文开始SSL通信，其中包含客户端支持的SSL指定版本，加密组件列表
2. 服务器可进行SSL通信时，会以Server Hello报文作为应答，也会在报文里包含SSL版本和加密组件（服务器的加密组件内容是从客户端发来的加密组件列表里筛选出来的）
3. 服务器发送Certificate报文，报文中包含公开密钥证书
4. 服务器发送Server Hello Done报文通知客户端，SSL握手协商部分结束
5. SSL第一次握手结束后，客户端以Client Key Exchange报文进行回应，其中包含通信加密中使用的一种被称为Pre-master secret的随机密码串，已经使用公开密钥进行加密
6. 客户端继续发送Change Cipher Spec报文以提示服务器，在此报文之后的通信采用Pre-master secret密钥进行加密
7. 客户端发送Finished报文，其中包含至今全部报文的整体校验值，此次握手协商的成功与否要以服务器能否正确解密该报文作为前提
8. 服务器同样发送Change Cipher Spec报文
9. 服务器同样发送Finished报文
10. 两边Finished报文交换完毕之后，SSL连接建立完成，此处开始进行应用层协议的通信，即发送HTTP请求 
11. 发送HTTP响应
12. 由客户端断开连接，发送close_notify报文，然后再发送TCP FIN报文以关闭TCP通信
<br>

在上面流程中应用层发送数据时会附加叫**MAC（Message Authentication Code）** 的报文摘要，用于查知报文是否遭到篡改

HTTPS的速度要比HTTP慢2~200倍。SSL的慢分两种：**通信慢和处理速度慢**，要进行SSL通信整体上处理的通信量会不可避免的增加。而且SSL必须进行加密处理，客户端和服务器都要进行加密和解密的运算处理，导致负载增强。由于这些原因，只要通信信息包含个人信息等敏感数据时才使用HTTPS加密通信（而且证书也贵）
* **
* ## 第八章 确认用户身份的认证

计算机本身无法判断坐在显示器前的是谁，也无法确认网络那头的人是谁。为了弄清楚是谁在访问服务器，就得让对方客户端自报家门。为了确认对方是否有访问权限，就得确认对方是否有“登录者本人才知道的信息”，如：

1. **密码：** 只有本人才会知道的字符串信息
2. **动态令牌：** 仅限本人持有的设备内显示的一次性密码
3. **数字证书：** 仅限本人（终端）持有的信息
4. **生物认证：** 指纹和虹膜等本人生理信息 
5. **IC卡等：** 仅限本人持有的信息

HTTP/1.1的认证方式：

1. **BASIC认证（基本认证）**
2. **DIGEST认证（摘要认证）**
3. **SSL客户端认证**
4. **FormBase认证（基于表单认证）**

**BASIC认证步骤：**

1. 当请求的资源需要BASIC认证时，服务器会随状态码401 Authorization Required返回带WWW-Authenticate首部字段的响应，其中包含认证方式（Basic）和Request-URI安全域字符串
2. 收到该响应的客户端为了通过BASIC认证，需要将用户ID和密码发送给服务器。字符串内容是经过Base64编码处理的用冒号隔开的ID和密码
3. 在接收到包含首部字段Authorization首部字段的请求后会对认证信息的正确性进行验证，如果通过就返回包含Request-URI资源的响应

BASIC认证虽然采取了Base64编码方式，但是这不是加密处理，在HTTP等非加密线路上进行BASIC认证如果被窃听，被盗的可能性很高。而且如果还想再进行一次BASIC认证的话，一般的浏览器无法实现注销操作

**DIGEST认证：**

为了弥补BASIC认证的缺点，从HTTP/1.1起就有了BASIC认证，它同样采用质询/响应的方式，但不会直接明文发送密码

其认证步骤如下：

1. 请求需要认证的资源时，服务器会随状态码401 Authorization Required返回带WWW-Authenticate首部字段的响应，其中包含认证方式（Digest）和质问响应方式认证所需的临时质询码（随机数，nonce）<br><br>**nonce**是每次返回401响应生成的随机任意字符串
2. 接收到401状态码的客户端，返回的响应中包含DIGEST认证必须的首部字段Authorization信息，其中包含**username、 realm、 nonce、 uri、response**的字段信息，realm和nonce就是之前从服务器接收到的响应中的字段<br><br>**uri**就是Request-URI的值，防止代理转发后Request-URI的值可能会被修改，会事先复制一份副本保存在uri内<br><br>**response**可以叫做Request-Digest，存放经过MD5运算后的密码字符串形成响应码
3. 接收到包含首部字段Authorization请求的服务器，会确认认证信息的正确性。认证通过后则返回包含Request-URI资源的响应

DIGEST安全性比BASIC要高，但是相比HTTPS还是很弱。DIGEST提供防止密码被窃听的保护机制，但不存在防止用户伪装的保护机制，而且用起来也不是很便捷，以适用范围也不大

**SSL客户端认证：**

SSL客户端认证可以避免用户ID和密码被盗从而被第三者冒充的情况

SSL客户端认证是借由HTTPS客户端证书完成认证的方式。其步骤如下：

1. 接收到认证请求，服务器发送Certificate Request报文，要求客户端提供客户端证书
2. 用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate报文方式发送给服务器
3. 服务器验证客户端证书通过后才能领取证书内的客户都安的公开密钥，开始HTTPS加密通信

一般来说SSL客户都安认证不会仅依靠证书来完成认证，会和基于表单认证组合成一种双因素认证。SSL客户都安认证确认这是客户端计算机，另一个认证用来确认这是用户本人的行为

**基于表单认证：**

该认证方法并不是在HTTP协议中定义的。客户端向服务器的Web应用程序发送登录信息，按登录信息的验证结果进行认证

因为使用时的便捷性和安全性问题，BASIC和DIGEST认证几乎不怎么使用，SSL客户端认证虽然安全等级高，但是因为导入和费用高还没普及

表单认证不具备共同规范，如果经过全面考虑，那么安全等级很高。

基于表单认证的标准规范尚未定论，一般用Cookie来管理会话（Session）

基于表单认证本身是通过服务器端的Web应用，将客户端发送过来的用户ID和密码与之前登陆过的信息匹配来认证的

但之前也提到过HTTP是无状态协议，不会对状态进行保存。所有我们使用Cookie来管理会话：

1. 客户端把用户ID密码放入报文实体部分，通常用POST方法把请求传给服务器，会使用HTTPS来显示HTML表单和发送数据
2. 服务器发放用来识别用户的Session ID，写在响应的Set-Cookie首部字段内（为了防止被盗或被猜出服务器要进行有效期管理，并使用难以猜测的字符串。并且为了防止跨站脚本攻击，要在Cookie里加上httponly属性）
3. 客户端收到Session ID后将其作为Cookie保存在本地，发送请求时浏览器会自动发送Cookie


（基于表单认证的登录信息和认证过程都没有标准化的方法，而且就连服务器端怎么保存用户提交的密码也没有标准化的方法。通常一种安全的保存方法是先给密码加盐（salt），然后利用散列（hash）函数计算出散列值后保存。明文保存也很常见，但会有泄露的风险）

（另：加盐就是由服务器随机生成一个很长的字符串，与密码字符串相连接然后计算散列值，这样即使两个用户的密码是一样的散列值也会不同，很大程度上减少了密码特征）
* **
* ## 第九章 基于HTTP的追加功能

随着时代的发展，HTTP功能上的不足已经逐渐显现，于是就有了一些基于HTTP的新协议，在HTTP的基础上添加了新功能

**SPDY**是由Google在2010年发布的，其开发目标旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间（50%）

**HTTP的瓶颈：** 在一些SNS网站上，很短的时间就会产生大量的请求。为了尽可能地实时反馈这些更新内容，服务器上一有内容更新就需要直接把那些内容反馈到客户端界面。如果使用HTTP协议探知更新，就需要频繁地向服务器端确认，会产生大量徒劳的通信

如果想实现这些功能，有些HTTP标准会成为瓶颈：

1. 一条连接上只可发送一个请求
2. 请求只能从客户端开始，客户端只能接收响应指令
3. 请求 / 响应首部未经压缩就发送。首部信息越多延迟越大
4. 每次互相发送相同的首部造成的浪费较多
5. 可以任意选择压缩格式，非强制压缩
<br>

**Ajax（Asynchronous JavaScript and XML，异步JavaScript与XML技术）** 有效利用了JS和DOM（Document Object Model，文档对象模型）的操作，达到局部Web页面替换加载的异步通信手段，和之前的同步通信相比因为只传输一部分页面所有传输数据量变少

其核心技术是叫做XMLHttpRequest的API，通过JavaScript脚本语言的调用就能和服务器进行HTTP通信，从而在已经加载完毕的Web页面上发起请求，只更新局部页面

但是使用Ajax实时从服务器获取内容，有可能会导致大量请求产生，它也没有解决HTTP协议本身存在的问题

**Comet**不会让请求等待服务器内容更新，而是已有资源更新直接向客户端返回响应，通过延迟应答模拟服务器端向客户端推送的功能

通常服务器都是立刻处理请求并返回响应，但为了实现推送功能，Comet将响应处于挂起状态，一旦服务器有资源更新，再返回响应。虽然做到了实时更新，但是一次连接的持续时间也变长了，会消耗更多资源，同时它也没有解决HTTP协议本身存在的问题

虽然这两个办法一定程度上使HTTP得到了改善，但没有消除HTTP的瓶颈，处于持续开发中的SPDY正是为了在协议级别消除HTTP所遭遇的瓶颈

**SPDY**没有完全改写HTTP协议，而是在TCP/IP的应用层和运输层直接通过新加**会话层**的形式运作，同时考虑到安全性，它规定通信中使用SSL

SPDY以会话层形式加入，控制对数据的流动，但还是采用HTTP建立通信连接。在使用SPDY后，HTTP协议额外获得以下功能

1. **多路复用流**
通过单一的TCP连接，可以无限制处理多个HTTP请求。所有请求在一条TCP连接上完成，处理效率高
2. **赋予请求优先级**
SPDY不仅可以无限制地并发请求，还可以给请求赋予优先级顺序，这样可以在发送多个请求时解决因宽带低导致的响应变慢
3. **压缩HTTP首部**
压缩请求和响应的HTTP首部，减少发送的字节数
4. **推送功能**
支持服务器向客户端推送，不必等待客户端请求
5. **服务器提示功能**
服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。

**WebSocket**是HTML5标准的一部分，现在它逐渐变成了独立的协议，它是为了解决Ajax和Comet里XMLHttpReques附带的缺陷所引起的问题

一旦服务器和客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。

因为是建立在HTTP基础上的协议，所有连接的发起方仍然是客户端，但是一旦WebSocket通信建立，不管是哪一方都可以直接向对方发送报文

其特点如下：

1. **推送功能**
服务器直接向客户端发送数据的推送功能，不必等待客户端请求
2. **减少通信量**
只要建立起WebSocket连接， 就希望一直保持连接状态，并且其首部信息很小
<br>
为了完成WebSocket通信，需要在HTTP连接建立后完成“握手”的步骤，**请求**时用Upgrade首部字段告知服务器通信协议发生改变，达到握手的目的

Sec-WebSocket-Key字段内记录着握手过程中必不可少的键值。Sec-WebSocket-Protocol字段内记录使用的子协议

对应之前的请求，**响应**返回状态码101 Switching Protocols

成功握手确立WebSocket连接之后， 通信时不再使用 HTTP 的数据帧， 而采用WebSocket独立的数据帧

HTTP/2.0的七项技术讨论：
|||
|--|--|
|压缩|SPDY、 Friendly|
|多路复用|SPDY|
|TLS 义务化|Speed＋ Mobility|
|协商|Speed＋ Mobility， Friendly|
|客户端拉曳（Client Pull） /服务器推送（Server Push）|Speed＋ Mobility|
|流量控制|SPDY|
|WebSocket|Speed＋ Mobility|
<br>

**WebDAV** 是一个可以对Web服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。它作为扩展HTTP/1.1协议定义在RFC4918

除了上面的基本功能，它还能进行文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能，还有对文件修改的版本控制功能

WebDAV针对服务器上的资源做了一些概念扩展：

1. **集合**是一种统一管理多个资源的概念，以集合为单位可以进行各种操作，集合也可以嵌套
2. **资源**是指文件或集合
3. **属性：** 资源属性的定义以“名称=值”的格式执行
4. **锁**会把文件设置成无法编辑状态，多人同时编辑时可以防止在同一时间进行内容写入

WebDAV为了实现远程资源管理，还向HTTP/1.1追加了一些方法和状态码：
|方法| 描述 |
|--|--|
| **PROPFIND** | 获取属性 |
| **PROPPATCH** | 修改属性 |
|**MKCOL**  | 创建集合 |
| **COPY** | 复制资源和属性 |
| **MOVE** | 移动资源 |
| **LOCK** | 资源加锁 |
| **UNLOCK** | 资源解锁 |

| 状态码 | 描述 |
| -- | --|
|**102 Processing**|可正常处理请求， 但目前是处理中状态|
|**207 Multi-Status**|存在多种状态|
|**422 Unprocessible Entity**|格式正确，内容有误|
|**423 Locked**|资源已经被上锁|
|**424 Failed Dependency**|处理与某请求关联的请求失败，不再维持依赖关系|
|**507 Insufficient Storage**|保存空间不足|

* **
* ## 第十章 构建Web内容的技术

Web页面几乎全由HTML构建。动态HTML指的是使用客户端脚本将静态的HTML内容变成动态的技术的总称。这是通过调用JS实现对HTML的Web页面的动态改造，利用DOM（Document Object Model，文档对象模型）可指定欲发生动态变化的HTML元素

**DOM**是用以操作XML文档的API，使用DOM可以将HTML的元素当对象操作。通过JS等脚本语言对DOM的操作，可以用更简单的方法控制HTML的改变

**Web**应用指的是通过Web功能提供的应用程序。原来应用HTTP协议的Web机制就是对客户端发来的请求返回准备好的内容。但随着Web的普及，需要引入由程序创建HTML内容的做法。这种由程序创建的内容称为动态内容

**CGI（Common Gateway Interface，通用网关接口）** 是指服务器在接收到客户端发送过来的请求后转发给程序的一组机制。

使用CGI的程序叫做CGI程序，通常由Perl、PHP、Ruby和C等编程语言编写而成

**Servlet**是一种能在服务器上创建动态内容的程序，它是用Java语言实现的一个接口，属于面向企业级Java的一部分

CGI由于每次收到请求程序都要启动一次，在访问量过大时负载很大，但Servlet运行在与Web服务器相同的进程中，受到的负载较小。Servlet作为解决CGI问题的对抗技术，随Java一起得到了普及

**XML（eXtensible Markup Language，可扩展标记语言）** 是一种可按应用目标进行扩展的通用语言标记。旨在通过XML使互联网数据共享变得容易

它和HTML一样都是从SGML简化而成，但它对数据的记录方式做了特殊处理

XML和HTML一样，使用标签构成树形结构，并且可自定义扩展标签。从XML文档中读取数据比HTML更简单，因为其结构基本上都是用标签分割而成的树形结构。更容易地复用数据使XML在互联网被广泛接受

**RSS（简易信息聚合，也叫聚合内容）** 和**Atom**都是发布新闻或博客日志等更新信息文档的格式的总称，两者都用到了XML

**JSON（JavaScript Object Notation）** 是以JS的对象表示法为基础的轻量级标记语言，能处理的数据类型有false/null/true/ 对象 / 数组 / 数字 / 字符串

它让数据更轻更纯粹，可以被JS更轻易读入。另外，其他各种编程语言也提供丰富的库类，以达到轻便操作 JSON 的目的
* **
* ## 第十一章 Web的攻击技术

互联网上的攻击大多以Web站点作为攻击目标

简单的HTTP协议本身不存在安全性问题，所以不会将协议本身作为攻击对象。攻击对象是应用HTTP协议的服务器、客户端和运行在服务器上的Web应用等资源。大多数来自互联网的攻击目标都是Web站点

HTTP就是一个单纯的协议机制，具备较多优势，但随在安全性方面呈现劣势，需要开发者自行设计并开发会话管理功能，可能存在安全漏洞

在HTTP请求报文内加载攻击代码，就能发起对Web应用的攻击。通过URL查询字段或表单、HTTP首部、Cookie等途径把攻击代码传入，如果Web应用存在漏洞，内部信息就会遭到窃取或被攻击者拿到管理权限

对Web应用的攻击有两种形式：**主动攻击、被动攻击**

主动攻击指的是攻击者通过直接访问Web应用，把攻击代码传入的攻击方式。因为是要针对服务器上的资源进行攻击，所以需要攻击者能够访问到那些资源

主动攻击具有代表性的是**SQL注入攻击**和**OS命令**注入攻击

被动攻击是指利用圈套策略执行攻击代码的攻击模式，攻击者不直接对Web应用访问发动攻击，步骤如下

1. 诱使用户触发已经设置好的陷阱，陷阱启动发送嵌入攻击代码的HTTP请求
2. 中招之后用户的浏览器或邮件客户端就会触发这个陷阱
3. 中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用，运行攻击代码
4. 执行完攻击代码，存在安全漏洞的Web应用就会成为攻击者的跳板，可能会使用户Cookie泄露或登录状态用户权限遭恶意篡改

被动攻击中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造

利用被动攻击可以对原本互联网上无法直接访问的企业内网进行攻击

**跨站脚本攻击**指的是通过存在安全漏洞的Web网站注册用户的浏览器运行非法的HTML标签或者JS进行的一种攻击。动态创建的 HTML部分有可能隐藏着安全漏洞

**SQL注入攻击**是指针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击。该安全隐患可能引发极大的威胁。

Web应用通常会用到数据库，会使用SQL语句连接数据库进行指定的操作，如果在调用SQL语句上存在漏洞，就有可能执行被恶意注入的非法SQL语句

SQL注入是攻击者将 SQL语句改变成开发者意想不到的形式以达到破坏结构的攻击

**OS命令注入攻击**是指通过Web应用，执行非法的操作系统命令达到攻击的目的，只要是在能调用Shell函数的地方就有存在被攻击的风险

OS命令注入攻击可以向Shell发送命令，让Windows或Linux操作系统的命令行启动程序

**HTTP首部注入攻击**是指攻击者在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击，属于被动攻击模式

比如说攻击者发送请求```101%0D%0ASet-Cookie:+SID=123456789```，其中```%0D%0A```是HTTP报文中的换行符后面是强制将攻击者网站的会话ID设置成SID=123456789的Set-Cookie首部字段。如果结果返回以下响应：
```
Location: http://example.com/?cat=101（%0D%0A ： 换行符） 
Set-Cookie: SID=123456789
```
这时首部字段Set-Cookie已经生效，攻击者可以指定修改任意的Cookie信息，通过和绘画固定攻击组合，攻击者可以伪装成用户

本来的```%0D%0A```属于Location的查询值部分，但经过解析后变成了换行符，结果插入了新的首部字段

**HTTP响应截断攻击**是用在HTTP首部注入的一种攻击。攻击顺序相同，但随要将两个```%0D%0A```并排插入字符串后发送，这样就可以作出HTTP首部和主体分隔所需的空行从而显示伪造的主体

**邮件首部注入攻击**是指Web应用中的邮件发送功能，攻击者通过向邮件首部To或Subject内任意添加非法内容发起攻击。通过存在安全漏洞的Web网站对任意邮件地址发送广告邮件或病毒邮件

**目录遍历攻击**是指对无意公开的文件目录通过非法截断其目录路径后达成访问目的的一种攻击，有时候也被叫做**路径遍历攻击**

在由外部指定文件名的处理存在疏漏的情况下，用户可使用 .../ 等相对路径定位到 /etc/passwd 等绝对路径上，服务器上的任意文件或文件目录都有可能被访问到

**远程文件包含漏洞**是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，脚本读取后就可以运行任意脚本的一种攻击

这主要是PHP存在的漏洞，因为太过危险在PHP5.2.0之后默认设定此功能无效

还有一些因设置或设计上的缺陷引发的安全漏洞

**强制浏览**安全漏洞指的是从安置在Web服务器的公开目录下的文件中浏览原本非自愿公开的文件

一般来说它们的URL是隐藏的，但一旦被人发现或猜到就可以浏览其对应的文件

**不正确的错误消息处理**是指Web应用的错误信息里包含对攻击者有用的信息。对应这种情况各系统应对详细的错误消息进行抑制设定，或使用自定义错误消息，以避免某些错误信息给攻击者以启发

**开发重定向**功能的安全漏洞是如果重定向URL到某个恶意Web网站，那么用户就会到那个网站去

```
http://example.com/?redirect=http://www.tricorder.jp
```
攻击者把指定的参数进行修改
```
http://example.com/?redirect=http://hackr.jp
```
<br>
用户原以为访问example.com，但被诱导到了hackr.jp这个重定向目标

会话管理是管理用户状态的必备功能，但如果有疏忽也会导致严重后果

**会话劫持**指的是攻击者通过某种手段拿到用户的会话ID，非法使用此ID伪造成用户从而完成攻击。他可能使用的手段可能是：**通过非正规的生成方法推测会话ID、通过窃听或XSS攻击盗取会话ID、通过会话固定攻击（ Session Fixation）强行获取会话ID等等等等**

和窃取目标会话ID的主动攻击手段不同，**会话固定攻击**会强制用户使用攻击者指定的会话ID，属于被动攻击

**跨站点请求伪造**是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击

还有一些其他的安全漏洞

**密码破解**即算出密码突破认证，这不仅限于Web应用，还包括其它系统，它有两种手段：**通过网络的密码试错、对已加密的密码破解**

出去突破认证的攻击手段，还有SQL注入攻击逃避认证，跨站脚本攻击窃取密码信息的方法

密码试错主要有两种办法：**穷举法和字典攻击**

**穷举法**又叫暴力破解法，用所有可行的密码进行试错，但是当密钥空间很庞大时，试出密码要很久

**字典攻击**是利用事先收集好的密码，枚举字典种的密码进行尝试，虽然时间会比穷举法短，但是字典里得包含正确的密码

字典攻击中有一种利用其他Web网站已泄露的ID及密码列表进行的攻击，这样成功率很高

破解加密密码需要从以某种手段得到的密码数据中解码，将加密后的密码还原成明文形式，一般有这些方法：**通过穷举法·字典攻击进行类推、彩虹表、拿到密钥、加密算法的漏洞**

（**彩虹表**是由明文密码及与之对应的散列值构成的一张数据库表是一种通过事先制作庞大的彩虹表，可在穷举法/字典攻击等实际破解过程中缩短消耗时间的技巧。从彩虹表内搜索散列值就可以推导出对应的明文密码）

**点击劫持**是指利用透明的按钮或者链接做成陷阱，覆盖在整个Web页面上，用户在不知情的情况下点击从而达成攻击的手段

**DoS**攻击是一种让运行中的服务器呈停止状态的攻击，它的攻击对象除了Web还有网络设备和服务器，主要有两种方式：**1.集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态 2.通过攻击安全漏洞使服务停止**

由多台计算机发起的DoS被称为**DDoS**攻击，DDoS攻击通常利用那些感染病毒的计算机作为攻击者的跳板（肉鸡）

**后门程序**指的是开发设置的隐藏入口，可以不按正常步骤使用受限功能，分为三种类型：**开发时作为Debug时调用的后门程序、开发者为了自身利益植入的后门程序、攻击者植入的后门程序**
* **
